\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Custom commands
\usepackage{mystyle}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{
    ``Encrypt-then-MAC'' with Kyber/ML-KEM is insecure
}
\author{
    Ganyu Xu
}
% Leave the date field empty to display the date of compilation
% \date{}

\begin{document}
%%%% TITLE %%%%%
\maketitle

After some additional thoughts I found a chosen-ciphertext attack against the ``Encrypt-then-MAC'' transformation when combined with Kyber/ML-KEM. This attack takes advantage of the general structure of LWE-based cryptosystem, and I have no immediate ways to patch this problem. Unfortunately I think this means that $\etm$ is a dead end with lattice-based schemes.

\section{A plaintext-checking attack against Kyber}
Recall the construction of \monospace{Kyber.CPAPKE}

\begin{figure}[H]
    \begin{minipage}{0.3\textwidth}
        \begin{algorithm}[H]
            \caption{$\keygen_\pke$}\label{alg:kyber-pke-keygen}
            \begin{algorithmic}[1]
                \State $A \leftsample R_q^{k \times k}
                    , \mathbf{s} \leftsample \mathcal{X}_{\eta_1}^k$
                \State $\mathbf{t} \leftarrow A \cdot \mathbf{s}$
                \State $\pk \leftarrow (A, \mathbf{t}), \sk \leftarrow \mathbf{s}$
                \State \Return $(\pk, \sk)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\textwidth}
        \begin{algorithm}[H]
            \caption{$\encrypt_\pke(\pk, m)$}\label{alg:kyber-pke-encrypt}
            \begin{algorithmic}[1]
                \State $(A, \mathbf{t}) \leftarrow \pk$
                \State $\mathbf{r}_1 \leftsample \mathcal{X}_{\eta_1}^k$
                \State $\mathbf{e}_1 \leftsample \mathcal{X}_{\eta_2}^k,
                    e_2 \leftsample \mathcal{X}_{\eta_2}$
                \State $\mathbf{c}_1 \leftarrow A^\intercal \cdot \mathbf{r}_1 + \mathbf{e}_1$
                \State $c_2 \leftarrow \mathbf{t}^\intercal \cdot \mathbf{r}_1 + e_2 + m \cdot \round{\frac{q}{2}}$
                \State \Return $(\mathbf{c}_1, c_2)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\textwidth}
        \begin{algorithm}[H]
            \caption{$\decrypt_\pke(\sk, c)$}\label{alg:kyber-pke-decrypt}
            \begin{algorithmic}[1]
                \State $(\mathbf{c}_1, c_2) \leftarrow c$
                \State $\mathbf{s} \leftarrow \sk$
                \State $\hat{m} = c_2 - \mathbf{s}^\intercal \cdot \mathbf{c}_1$
                \State $\hat{m} \leftarrow \operatorname{Round}(\hat{m})$
                \State \Return $\hat{m}$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{$\pke$ routines}\label{fig:kyber-pke-routines}
\end{figure}

This construction has no ciphertext integrity, meaning that an adversary can submit well-formed AND malformed ciphertexts and recover the secret key by observing the behavior of the decryption routine. Here we present a plaintext-checking attack, which uses a plaintext checking oracle:

\begin{figure}[H]
    \center
    \begin{minipage}{0.3\textwidth}
        \begin{algorithm}[H]
            \caption{$\pco(m, c)$}
            \begin{algorithmic}[1]
                \State \Return $\llbrack \decrypt(\sk, c) = m \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
\end{figure}

Also recall that with Kyber/ML-KEM, each polynomial can be transformed into the NTT domain:

\begin{equation*}
    R_q = \frac{\mathbb{Z}_{3329}[x]}{\left\langle x^{256} + 1 \right\rangle}
    \cong \frac{\mathbb{Z}_{3329}[x]}{\left\langle x^2 + \zeta \right\rangle}
    \times \frac{\mathbb{Z}_{3329}[x]}{\left\langle x^2 + \zeta^3 \right\rangle}
    \times \ldots
    \times \frac{\mathbb{Z}_{3329}[x]}{\left\langle x^2 + \zeta^{255} \right\rangle}
\end{equation*}

Where $\zeta$ is any solution to $\zeta^{128} + 1 \equiv 0 \mod 3329$ (Kyber picked $\zeta=17$). We denote the NTT representation by:

\begin{equation*}
    \ntt(y \in R_q) = (\hat{y}_1, \hat{y}_2, \ldots, \hat{y}_{128})
\end{equation*}

Where each $\hat{y}_j$ for $1 \leq j \leq 128$ is a degree-1 polynomial.

For each of $i \in \{1, 2, \ldots, k\}$ and each of $j \in \{1, 2, \ldots, 128\}$, an adversary can craft a maliciously malformed ciphertext $c = (\mathbf{c}_1, c_2)$ such that:

\begin{itemize}
    \item $\ntt(c_2) = (0, 0, \ldots, \hat{c}_{2, j}, \ldots, 0)$ is all 0's except for the j-th entry, which is chosen by the adversary
    \item $\mathbf{c}_1 = (0, 0, \ldots, c_{1, i}, \ldots, 0)$ is all 0's except for the i-th entry $c_{1, i}$, whose NTT representation $\ntt(c_{1, i}) = (0, 0, \ldots, \hat{c}_{1, i, j} = 1, \ldots, 0)$ is all 0's except for the j-th entry, which is 1.
\end{itemize}

In line 3 of the decryption routine (algorithm \ref{alg:kyber-pke-decrypt}):

\begin{equation*}
    \begin{aligned}
        \ntt(c_2 - \mathbf{s}^\intercal \cdot \mathbf{c}_1)
        &= \ntt(c_2) - \ntt(\mathbf{s}^\intercal \cdot \mathbf{c}_1) \\
        &= (0, 0, \ldots, \hat{c}_{2, j}, \ldots, 0)
            - \ntt(s_i \cdot c_{1, i}) \\
        &= (0, 0, \ldots, \hat{c}_{2, j}, \ldots, 0)
            - \ntt(s_i) \circ \ntt(c_{1, i}) \\
        &= (0, 0, \ldots, \hat{c}_{2, j}, \ldots, 0)
            - (\hat{s}_{i, 1}, \hat{s}_{i, 2}, \ldots, \hat{s}_{i, 128})
            \circ (0, 0, \ldots, c_{1, i, j} = 1, \ldots, 0) \\
        &= (0, 0, \ldots, \hat{c}_{2, j} - \hat{s}_{i, j}, \ldots, 0)
    \end{aligned}
\end{equation*}

I will make an unverified but probably correct claim: \emph{if $\hat{c}_{2, j} - \hat{s}_{i, j} \neq 0$ then with very high probability $\ntt^{-1}((0, 0, \ldots, \hat{c}_{2, j} - \hat{s}_{i, j}, \ldots, 0))$ will not round to $0$}. This means that with very high probability, $(\mathbf{c}_1, c_2)$ will not decrypt to $0$ if $\hat{c}_{2, j} \neq \hat{s}_{i, j}$, which is equivalent to $\pco(m=0, c=(\mathbf{c}_1, c_2)) = 0$.

The adversary can thus iterate through all $q^2$ possible degree-1 polynomials to find the correct value for $\hat{s}_{i, j}$, then repeat it for all $i, j$. In $q^2 \cdot k \cdot \frac{n}{2}$ operations, the adversary can recover the secret key.

\section{$\etm$ is vulnerable to the key recovery attack above}
Suppose an adversary crafts a malicious ciphertext using the strategy described above $c = (\mathbf{c}_1, c_2)$, if the secret key value is such that $\hat{c}_{2, j} = \hat{s}_{i, j}$, then $m = 0$ should be the correct decryption, which means that $k = G(0)$ should be the correct MAC key, so the adversary computes the tag $t = \sign(G(0), c)$.

If $(c, t)$ is rejected, then the adversary learns that $0$ is not the correct decryption. From here the key recovery attack described above can be executed. A similar attack can be executed using $\pco$ against $\etm$. This means that at least with Kyber/ML-KEM, $\etm$ is not one-way secure with either $\pco$ or $\cvo$.

\end{document}