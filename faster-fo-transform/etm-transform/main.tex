\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
% \usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}

% \usepackage{floatrow}

\newcommand{\monospace}{\texttt}
\newcommand{\pke}{\monospace{PKE}}
\newcommand{\keygen}{\monospace{KeyGen}}
\newcommand{\encrypt}{\monospace{E}}
\newcommand{\decrypt}{\monospace{D}}
\newcommand{\kem}{\monospace{KEM}}
\newcommand{\encap}{\monospace{Encap}}
\newcommand{\decap}{\monospace{Decap}}
\newcommand{\etm}{\monospace{EtM}}  % encrypt-then-mac
\newcommand{\mac}{\monospace{MAC}}
\newcommand{\sign}{\monospace{Sign}}
\newcommand{\verify}{\monospace{Verify}}
\newcommand{\pk}{\monospace{pk}}
\newcommand{\sk}{\monospace{sk}}
\newcommand{\pco}{\monospace{PCO}}
\newcommand{\cvo}{\monospace{CVO}}
\newcommand{\leftsample}{\stackrel{\$}{\leftarrow}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newcommand{\norm}[1]{\left\lvert #1 \right\rvert}
\newlength{\wdth}
\newcommand{\strike}[1]{\settowidth{\wdth}{#1}\rlap{\rule[.5ex]{\wdth}{.4pt}}#1}
\newcommand{\notrand}{{\strike{\$}}}
\newcommand{\rand}{\$}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{The ``encrypt-then-MAC'' transformations}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Encrypt-then-MAC transformations}
In this section we describe two ``encrypt-then-MAC'' transformations and discuss their security properties.

\begin{figure}[H]
    \center
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\encrypt_\etm(\pk, m)$}\label{alg:rand-etm-encrypt}
            \begin{algorithmic}[1]
                \State $k_\mac \leftarrow G(m)$  % Need to distinguish from the other G
                \State $c \leftarrow \encrypt(\pk, m)$
                    \Comment{If $\encrypt$ is randomized, then $\encrypt_\etm$ is randomized}
                \State $t \leftarrow \sign(k_\mac, c)$
                \State \Return $(c, t)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\decrypt_\etm(\sk, (c, t))$}\label{alg:rand-etm-decrypt}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk, c)$
                \State $\hat{k}_\mac \leftarrow G(\hat{m})$
                \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
                    \State \Return $\bot$
                \EndIf
                \State \Return $\hat{m}$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{
        $\etm$ transformation.
    }\label{fig:rand-etm}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\encrypt^\notrand_\etm(\pk, m)$}
      \begin{algorithmic}[1]
        \State $k_\mac \leftarrow G(m)$
        \State $r \leftarrow H(m)$
        \State $c \leftarrow \encrypt(\pk, m; r)$
        \State $t \leftarrow \sign(k_\mac, c)$
        \State \Return $(c, t)$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \hfill  % Add space between algorithms
  \begin{minipage}{.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\decrypt^\notrand_\etm(\sk, (c, t))$}
      \begin{algorithmic}[1]
        \State $\hat{m} \leftarrow \decrypt(\sk, c)$
        \State $\hat{k}_\mac \leftarrow G(\hat{m})$
        \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
          \State \Return $\bot$
        \EndIf
        \State \Return $\hat{m}$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \caption{Derandomized encrypt-then-MAC}\label{fig:derand-etm}
\end{figure}

\begin{figure}[H]
    \center

    \begin{algorithm}[H]
        \caption{Sequence of games}\label{alg:sequence-of-games}

        \begin{algorithmic}
            \State $(\pk, sk) \leftsample \keygen(1^\lambda)$
            \State $m^\ast \leftsample \mathcal{M}_\pke$
            \State $k^\ast_\mac \leftarrow H(m^\ast)$
                \Comment{Game 0-2}
            \State $k^\ast_\mac \leftsample \mathcal{K}_\mac$
                \Comment{Game 3}
            \State $c^\ast \leftsample \encrypt(\pk, m)$
            \State $t^\ast \leftarrow \sign(k^\ast_\mac, c^\ast)$
            \State $
                \hat{m} \leftarrow 
                \mathcal{A}^{
                    \pco, \cvo, \mathcal{O}^H
                }(1^\lambda, \pk, (c^\ast, t^\ast))
            $
                \Comment{Game 0}
            \State $
                \hat{m} \leftarrow 
                \mathcal{A}^{
                    \pco_1, \cvo, \mathcal{O}^H
                }(1^\lambda, \pk, (c^\ast, t^\ast))
            $
                \Comment{Game 1}
            \State $
                \hat{m} \leftarrow 
                \mathcal{A}^{
                    \pco_1, \cvo_1, \mathcal{O}^H
                }(1^\lambda, \pk, (c^\ast, t^\ast))
            $
                \Comment{Game 2-3}
            \State \Return $\llbrack \hat{m} = m^\ast \rrbrack$
        \end{algorithmic}
    \end{algorithm}

    \caption{Sequence of games 0-3}\label{fig:sequence-of-games}
\end{figure}

\begin{figure}[H]
    \center

    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\pco(m, (c, t))$}\label{alg:pco-etm}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk, c)$
                \State $\hat{k}_\mac \leftarrow H(\hat{m})$
                \If{$\sign(\hat{k}_\mac, c) \neq t$}
                    \State \Return 0
                \EndIf
                \State \Return $\llbrack \hat{m} = m \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\pco_1(m, (c, t))$}\label{alg:pco1-etm}
            
            \begin{algorithmic}[1]
                \If{
                    $\exists (\tilde{m}, \tilde{k}) \in \mathcal{O}^H :
                        \tilde{m} = m \land \sign(\tilde{k}, c) = t
                    $
                }
                    \State \Return $1$
                \EndIf
                \State \Return $0$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}

    \caption{True $\pco$ and simulated $\pco$}\label{fig:pco-and-pco1}
\end{figure}

\begin{figure}[H]
    \center

    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\cvo(c, t)$}\label{alg:cvo-etm}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk, c)$
                \State $\hat{k}_\mac \leftarrow H(\hat{m})$
                \If{$\sign(\hat{k}_\mac, c) \neq t$}
                    \State \Return 0
                \EndIf
                \State \Return 1
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\cvo_1(c, t)$}\label{alg:cvo1-etm}
            
            \begin{algorithmic}[1]
                \If{
                    $\exists (\tilde{m}, \tilde{k}) \in \mathcal{O}^H :
                        \sign(\tilde{k}, c) = t
                    $
                }
                    \State \Return $1$
                \EndIf
                \State \Return $0$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}

    \caption{True $\cvo$ and simulated $\cvo_1$}\label{fig:cvo-and-cvo1}
\end{figure}

% \bibliographystyle{plain}
% \bibliography{./references.bib}

\end{document}