\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
% \usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}

% \usepackage{floatrow}

\newcommand{\monospace}{\texttt}
\newcommand{\pke}{\monospace{PKE}}
\newcommand{\keygen}{\monospace{KeyGen}}
\newcommand{\encrypt}{\monospace{E}}
\newcommand{\decrypt}{\monospace{D}}
\newcommand{\kem}{\monospace{KEM}}
\newcommand{\encap}{\monospace{Encap}}
\newcommand{\decap}{\monospace{Decap}}
\newcommand{\etm}{\monospace{EtM}}  % encrypt-then-mac
\newcommand{\mac}{\monospace{MAC}}
\newcommand{\sign}{\monospace{Sign}}
\newcommand{\verify}{\monospace{Verify}}
\newcommand{\pk}{\monospace{pk}}
\newcommand{\sk}{\monospace{sk}}
\newcommand{\pco}{\monospace{PCO}}
\newcommand{\cvo}{\monospace{CVO}}
\newcommand{\lwe}{\monospace{LWE}}
\newcommand{\cbd}{\monospace{CBD}}
\newcommand{\oracle}[1]{\mathcal{O}^{#1}}
\newcommand{\leftsample}{\stackrel{\$}{\leftarrow}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newcommand{\norm}[1]{\left\lvert #1 \right\rvert}
\newcommand{\round}[1]{\lceil #1 \rfloor}
\newlength{\wdth}
\newcommand{\strike}[1]{\settowidth{\wdth}{#1}\rlap{\rule[.5ex]{\wdth}{.4pt}}#1}
\newcommand{\notrand}{{\strike{\$}}}
\newcommand{\rand}{\$}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{The ``encrypt-then-MAC'' transformations}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
% \maketitle

\section{Preliminaries}
\subsection{Plaintext awareness}
\emph{Plaintext awareness (PA)}\cite{bellare1995optimal,bellare1998relations} describes the idea that no efficient algorithm can produce a valid ciphertext without knowing the corresponding decryption. 

Let $\pke = (\keygen, \encrypt, \decrypt)$ be a public-key encryption scheme. Let $H$ be a hash function. Let $\mathcal{E}^H_\pk$ be an encryption oracle that takes no argument and returns valid ciphertexts when queried. Under the random oracle model, hash queries made to the oracle $\mathcal{O}^H$ can be logged to a tape $\mathcal{L}^H = \{(h_i, H(h_i))\}$, and ciphertexts obtained from the encryption oracle are also logged to a separate tape $C = \{c : c \leftarrow \mathcal{E}^H_\pk(\cdot)\}$.

A plaintext-awareness adversary $B$ is a probabilistic algorithm that is given some public key and access to the two oracles, then output some ciphertext $c$. Note that the encryption oracle here is not redundant because obtaining ciphertexts from the encryption oracle will not log any corresponding hash queries in the hash oracle. This models a PA adversary's ability to obtain valid ciphertexts without running the encryption routine, such as by eavesdropping. The PA adversary $B$ outputs a ciphertext $c$ and the transcript $\mathcal{L}^H, C$ of its interactions with the oracles.

Let $K$ be some algorithm that outputs a decryption of $c$ using the corresponding transcript $\mathcal{L}^H, C$. We restrict $c \not \in C$ to prevent trivially turning $K$ into a decryption oracle. The plaintext awareness game is defined in figure \ref{fig:pa-game}.

\begin{figure}[H]
    \begin{algorithm}[H]
        \caption{Plaintext awareness game}\label{alg:pa-game}
        \begin{algorithmic}[1]
            \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
            \State $(\mathcal{L}^H, C, c) \leftarrow B^{H, \mathcal{E}^H_\pk}(1^\lambda, \pk)$
            \State $m \leftarrow K(1^\lambda, \pk, \mathcal{L}^H, C, c)$
            \State \Return $\llbrack c \not\in C \land m = D(\sk, c) \rrbrack$
        \end{algorithmic}
    \end{algorithm}
    \caption{The plaintext awareness game}\label{fig:pa-game}
\end{figure}

\begin{definition}
    A public-key encryption scheme is \emph{plaintext-aware} if there exists an efficient $K$ such that for all efficient PA adversaries $B$, the probability of $K$ failing to extract the correct decryption is negligible.

    \begin{equation*}
        P[\monospace{PA(K, B)} \neq 1] \leq \monospace{negl}(\lambda)
    \end{equation*}
\end{definition}

Note that our definition of plaintext awareness deviates from \cite{bellare1998relations} in that we do not require the $\pke$ to also be IND-CPA secure. This is because in constructing a key encapsulation mechanism using the Fujisaki-Okamoto transformation, we only require the input $\pke$ to be one-way secure, though under a stronger attack model. Restricting the definition to only the plaintext-awareness game allows us to combine PA with other security definition, such as OW-CPA, to prove stronger security result.

\section{Encrypt-then-MAC transformations}
Let $\pke(\keygen, \encrypt, \decrypt)$ be a probabilistic public-key encryption scheme defined over message space $\mathcal{M}_\pke$, ciphertext space $\mathcal{C}_\pke$, and coin space $\mathcal{R}_\pke$. Where the encryption routine is deterministic, we simply set the coin space to contain a single element $\mathcal{R} = \{r\}$. Let $\mac(\sign, \verify)$ be a message authentication code defined over key space $\mathcal{K}_\mac$. The message space of the $\mac$ should contain the ciphertext space of the $\pke$: $\mathcal{C}_\pke \subseteq \mathcal{M}_\mac$. Let $G: \mathcal{M}_\pke \rightarrow \mathcal{R}_\pke$ and $H: \mathcal{M}_\pke \rightarrow \mathcal{K}_\mac$ be hash functions.

The ``encrypt-then-MAC'' transformation $\pke_\etm(\keygen, \encrypt_\etm, \decrypt_\etm) = T_\etm(\pke, \mac, H)$ outputs a public-key encryption scheme where the key generation routine is identical to the input $\pke$'s key generation routine. The de-randomized ``encrypt-then-MAC'' transformation $\pke^\notrand_\etm(\keygen, \encrypt_\etm^\notrand, \decrypt^\notrand_\etm) = T^\notrand_\etm(\pke, \mac, G, H)$ similarly outputs a public-key encryption scheme. In both transformations, the key generation routine remains unchanged. The modified encryption and decryption routines are described in figure \ref{fig:rand-etm} and \ref{fig:derand-etm}.


\begin{figure}[H]
    \center
    \begin{minipage}{0.59\textwidth}
        \begin{algorithm}[H]
            \caption{$\encrypt_\etm(\pk, m)$}\label{alg:rand-etm-encrypt}
            \begin{algorithmic}[1]
                \State $r \leftsample \mathcal{R}_\pke$
                    \Comment{If $\encrypt$ is randomized, then $\encrypt_\etm$ is randomized}
                \State $k_\mac \leftarrow H(m)$  % Need to distinguish from the other G
                \State $c \leftarrow \encrypt(\pk, m; r)$
                \State $t \leftarrow \sign(k_\mac, c)$
                \State \Return $(c, t)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.39\textwidth}
        \begin{algorithm}[H]
            \caption{$\decrypt_\etm(\sk, (c, t))$}\label{alg:rand-etm-decrypt}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk, c)$
                \State $\hat{k}_\mac \leftarrow G(\hat{m})$
                \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
                    \State \Return $\bot$
                \EndIf
                \State \Return $\hat{m}$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{
        ``encrypt-then-MAC'' transformation
    }\label{fig:rand-etm}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\encrypt^\notrand_\etm(\pk, m)$}
      \begin{algorithmic}[1]
        \State $k_\mac \leftarrow H(m)$
        \State $r \leftarrow G(m)$
        \State $c \leftarrow \encrypt(\pk, m; r)$
        \State $t \leftarrow \sign(k_\mac, c)$
        \State \Return $(c, t)$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \hfill  % Add space between algorithms
  \begin{minipage}{.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\decrypt^\notrand_\etm(\sk, (c, t))$}
      \begin{algorithmic}[1]
        \State $\hat{m} \leftarrow \decrypt(\sk, c)$
        \State $\hat{k}_\mac \leftarrow G(\hat{m})$
        \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
          \State \Return $\bot$
        \EndIf
        \State \Return $\hat{m}$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \caption{
    de-randomized ``encrypt-then-MAC'' transformation
  }\label{fig:derand-etm}
\end{figure}

\begin{theorem}\label{thm:etm-is-ow-cca}
    If the $\mac$ is one-time unforgeable and $\pke$ is \monospace{OW-CPA} secure, then $\etm$ and $\etm^\notrand$ are both \monospace{OW-CCA} secure
\end{theorem}

We will prove theorem \ref{thm:etm-is-ow-cca} in two steps. First we show that $\etm$ and $\etm^\notrand$ are both plaintext-aware in section \ref{sec:etm-is-pa}, then we show that plaintext awareness and \monospace{OW-CPA} security imply \monospace{OW-CCA} security in section \ref{sec:pa-and-owcpa-imply-owcca}.

The KEM transformations from \cite{hofheinz2017modular} require the input $\pke$ to be OW-PCVA secure, although OW-PCVA security is implied by OW-CCA security

\begin{theorem}\label{thm:ow-cca-implies-ow-pcva}
    For every \monospace{OW-PCVA} adversary $\mathcal{A}_\monospace{PCVA}$ against some $\pke$, there exists an \monospace{OW-CCA} adversary $\mathcal{A}_\monospace{CCA}$ with identical advantage:

    \begin{equation*}
        \epsilon_\monospace{OW-PCVA} = \epsilon_\monospace{OW-CCA}
    \end{equation*}
\end{theorem}

\begin{proof}
    The \monospace{OW-CCA} adversary can perfectly simulate both the PCO and the CVO by replacing ``running decryption routine'' with ``querying the decryption oracle''. When the \monospace{OW-PCVA} adversary halts, the \monospace{OW-CCA} adversary passes \monospace{OW-PCVA} adversary's output as its own. Thus, \monospace{OW-CCA} adversary wins if and only if \monospace{OW-PCVA} adversary wins.
\end{proof}

\subsection{$\etm$ is plaintext aware}\label{sec:etm-is-pa}

\subsection{Plaintext awareness and OW-CPA imply OW-CCA}\label{sec:pa-and-owcpa-imply-owcca}

\bibliographystyle{alpha}
\bibliography{./references.bib}

\end{document}