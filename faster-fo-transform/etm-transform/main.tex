\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
% \usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}

% \usepackage{floatrow}

\newcommand{\monospace}{\texttt}
\newcommand{\pke}{\monospace{PKE}}
\newcommand{\keygen}{\monospace{KeyGen}}
\newcommand{\encrypt}{\monospace{E}}
\newcommand{\decrypt}{\monospace{D}}
\newcommand{\kem}{\monospace{KEM}}
\newcommand{\encap}{\monospace{Encap}}
\newcommand{\decap}{\monospace{Decap}}
\newcommand{\etm}{\monospace{EtM}}  % encrypt-then-mac
\newcommand{\mac}{\monospace{MAC}}
\newcommand{\sign}{\monospace{Sign}}
\newcommand{\verify}{\monospace{Verify}}
\newcommand{\pk}{\monospace{pk}}
\newcommand{\sk}{\monospace{sk}}
\newcommand{\pco}{\monospace{PCO}}
\newcommand{\cvo}{\monospace{CVO}}
\newcommand{\lwe}{\monospace{LWE}}
\newcommand{\cbd}{\monospace{CBD}}
\newcommand{\oracle}[1]{\mathcal{O}^{#1}}
\newcommand{\leftsample}{\stackrel{\$}{\leftarrow}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newcommand{\norm}[1]{\left\lvert #1 \right\rvert}
\newcommand{\round}[1]{\lceil #1 \rfloor}
\newlength{\wdth}
\newcommand{\strike}[1]{\settowidth{\wdth}{#1}\rlap{\rule[.5ex]{\wdth}{.4pt}}#1}
\newcommand{\notrand}{{\strike{\$}}}
\newcommand{\negl}[1]{\operatorname{negl}\left(#1\right)}
\newcommand{\rand}{\$}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{The ``encrypt-then-MAC'' transformations}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
% \maketitle

\section{Preliminaries}
\subsection{Plaintext awareness}
\emph{Plaintext awareness (PA)}\cite{bellare1995optimal,bellare1998relations} describes the idea that no efficient algorithm can produce a valid ciphertext without knowing the corresponding decryption. 

Let $\pke = (\keygen, \encrypt, \decrypt)$ be a public-key encryption scheme. Let $H$ be a hash function. Let $\mathcal{E}^H_\pk$ be an encryption oracle that takes no argument and returns valid ciphertexts when queried. Under the random oracle model, hash queries made to the oracle $\mathcal{O}^H$ can be logged to a tape $\mathcal{L}^H = \{(h_i, H(h_i))\}$, and ciphertexts obtained from the encryption oracle are also logged to a separate tape $C = \{c : c \leftarrow \mathcal{E}^H_\pk(\cdot)\}$.

A plaintext-awareness adversary $B$ is a probabilistic algorithm that is given some public key and access to the two oracles, then output some ciphertext $c$. Note that the encryption oracle here is not redundant because obtaining ciphertexts from the encryption oracle will not log any corresponding hash queries in the hash oracle. This models a PA adversary's ability to obtain valid ciphertexts without running the encryption routine, such as by eavesdropping. The PA adversary $B$ outputs a ciphertext $c$ and the transcript $\mathcal{L}^H, C$ of its interactions with the oracles.

Let $K$ be some algorithm that outputs a decryption of $c$ using the corresponding transcript $\mathcal{L}^H, C$. We restrict $c \not \in C$ to prevent trivially turning $K$ into a decryption oracle. The plaintext awareness game is defined in figure \ref{fig:pa-game}.

\begin{figure}[H]
    \begin{algorithm}[H]
        \caption{Plaintext awareness game}\label{alg:pa-game}
        \begin{algorithmic}[1]
            \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
            \State $(\mathcal{L}^H, C, c) \leftarrow B^{H, \mathcal{E}^H_\pk}(1^\lambda, \pk)$
            \State $m \leftarrow K(1^\lambda, \pk, \mathcal{L}^H, C, c)$
            \State \Return $\llbrack c \not\in C \land m = D(\sk, c) \rrbrack$
        \end{algorithmic}
    \end{algorithm}
    \caption{The plaintext awareness game}\label{fig:pa-game}
\end{figure}

\begin{definition}
    A public-key encryption scheme is \emph{plaintext-aware} if there exists an efficient $K$ such that for all efficient PA adversaries $B$, the probability of $K$ failing to extract the correct decryption is negligible.

    \begin{equation*}
        P[\monospace{PA(K, B)} \neq 1] \leq \monospace{negl}(\lambda)
    \end{equation*}
\end{definition}

Note that our definition of plaintext awareness deviates from \cite{bellare1998relations} in that we do not require the $\pke$ to also be IND-CPA secure. This is because in constructing a key encapsulation mechanism using the Fujisaki-Okamoto transformation, we only require the input $\pke$ to be one-way secure, though under a stronger attack model. Restricting the definition to only the plaintext-awareness game allows us to combine PA with other security definition, such as OW-CPA, to prove stronger security result.

\section{Encrypt-then-MAC transformations}
Let $\pke(\keygen, \encrypt, \decrypt)$ be a probabilistic public-key encryption scheme defined over message space $\mathcal{M}_\pke$, ciphertext space $\mathcal{C}_\pke$, and coin space $\mathcal{R}_\pke$. Where the encryption routine is deterministic, we simply set the coin space to contain a single element $\mathcal{R} = \{r\}$. Let $\mac(\sign, \verify)$ be a message authentication code defined over key space $\mathcal{K}_\mac$. The message space of the $\mac$ should contain the ciphertext space of the $\pke$: $\mathcal{C}_\pke \subseteq \mathcal{M}_\mac$. Let $G: \mathcal{M}_\pke \rightarrow \mathcal{R}_\pke$ and $H: \mathcal{M}_\pke \rightarrow \mathcal{K}_\mac$ be hash functions.

The ``encrypt-then-MAC'' transformation $\pke_\etm(\keygen, \encrypt_\etm, \decrypt_\etm) = T_\etm(\pke, \mac, H)$ outputs a public-key encryption scheme where the key generation routine is identical to the input $\pke$'s key generation routine. The de-randomized ``encrypt-then-MAC'' transformation $\pke^\notrand_\etm(\keygen, \encrypt_\etm^\notrand, \decrypt^\notrand_\etm) = T^\notrand_\etm(\pke, \mac, G, H)$ similarly outputs a public-key encryption scheme. In both transformations, the key generation routine remains unchanged. The modified encryption and decryption routines are described in figure \ref{fig:rand-etm} and \ref{fig:derand-etm}.


\begin{figure}[H]
    \center
    \begin{minipage}{0.59\textwidth}
        \begin{algorithm}[H]
            \caption{$\encrypt_\etm(\pk, m)$}\label{alg:rand-etm-encrypt}
            \begin{algorithmic}[1]
                \State $r \leftsample \mathcal{R}_\pke$
                    \Comment{If $\encrypt$ is randomized, then $\encrypt_\etm$ is randomized}
                \State $k_\mac \leftarrow H(m)$  % Need to distinguish from the other G
                \State $c \leftarrow \encrypt(\pk, m; r)$
                \State $t \leftarrow \sign(k_\mac, c)$
                \State \Return $(c, t)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.39\textwidth}
        \begin{algorithm}[H]
            \caption{$\decrypt_\etm(\sk, (c, t))$}\label{alg:rand-etm-decrypt}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk, c)$
                \State $\hat{k}_\mac \leftarrow G(\hat{m})$
                \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
                    \State \Return $\bot$
                \EndIf
                \State \Return $\hat{m}$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{
        ``encrypt-then-MAC'' transformation
    }\label{fig:rand-etm}
\end{figure}

\begin{figure}[H]
  \begin{minipage}{0.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\encrypt^\notrand_\etm(\pk, m)$}
      \begin{algorithmic}[1]
        \State $k_\mac \leftarrow H(m)$
        \State $r \leftarrow G(m)$
        \State $c \leftarrow \encrypt(\pk, m; r)$
        \State $t \leftarrow \sign(k_\mac, c)$
        \State \Return $(c, t)$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \hfill  % Add space between algorithms
  \begin{minipage}{.49\textwidth}  % Adjust width as needed
    \begin{algorithm}[H]
      \caption{$\decrypt^\notrand_\etm(\sk, (c, t))$}
      \begin{algorithmic}[1]
        \State $\hat{m} \leftarrow \decrypt(\sk, c)$
        \State $\hat{k}_\mac \leftarrow G(\hat{m})$
        \If{$\verify(\hat{k}_\mac, c, t) \neq 1$}
          \State \Return $\bot$
        \EndIf
        \State \Return $\hat{m}$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \caption{
    de-randomized ``encrypt-then-MAC'' transformation
  }\label{fig:derand-etm}
\end{figure}

\begin{theorem}\label{thm:etm-is-ow-cca}
    If the $\mac$ is one-time unforgeable and $\pke$ is \monospace{OW-CPA} secure, then $\etm$ and $\etm^\notrand$ are both \monospace{OW-CCA} secure
\end{theorem}

We will prove theorem \ref{thm:etm-is-ow-cca} in two steps. First we show that $\etm$ and $\etm^\notrand$ are both plaintext-aware in section \ref{sec:etm-is-pa}, then we show that plaintext awareness and \monospace{OW-CPA} security imply \monospace{OW-CCA} security in section \ref{sec:pa-and-owcpa-imply-owcca}.

The KEM transformations from \cite{hofheinz2017modular} require the input $\pke$ to be OW-PCVA secure, although OW-PCVA security is implied by OW-CCA security

\begin{theorem}\label{thm:ow-cca-implies-ow-pcva}
    For every \monospace{OW-PCVA} adversary $\mathcal{A}_\monospace{PCVA}$ against some $\pke$, there exists an \monospace{OW-CCA} adversary $\mathcal{A}_\monospace{CCA}$ with identical advantage:

    \begin{equation*}
        \epsilon_\monospace{OW-PCVA} = \epsilon_\monospace{OW-CCA}
    \end{equation*}
\end{theorem}

\begin{proof}
    The \monospace{OW-CCA} adversary can perfectly simulate both the PCO and the CVO by replacing ``running decryption routine'' with ``querying the decryption oracle''. When the \monospace{OW-PCVA} adversary halts, the \monospace{OW-CCA} adversary passes \monospace{OW-PCVA} adversary's output as its own. Thus, \monospace{OW-CCA} adversary wins if and only if \monospace{OW-PCVA} adversary wins.
\end{proof}

\subsection{$\etm$ is plaintext aware}\label{sec:etm-is-pa}
I want to prove that $\etm$ is plaintext aware by showing that if $\etm$ is not plaintext aware, then the underlying $\mac$ is broken. For clearer notations we denote unauthenticated ciphertexts by $\sigma \in \mathcal{C}_\pke$ and authenticated ciphertexts by $c = (\sigma, t)$.

If there exists a PA adversary $B$ with output $(\mathcal{L}^{G, H, \mathcal{R}}, C, c=(\sigma, t)) \leftarrow B(\cdot)$ such that for all knowledge extractor $K$

\begin{equation*}
    P \left\lbrack
    K(\mathcal{L}^{G, H, \mathcal{R}}, C, c=(\sigma, t)) \neq \decrypt_\etm(\sk, c)
    \right\rbrack > \negl{\lambda}
\end{equation*}

If $B$ produces a valid ciphertext $c = (\sigma, t)$, then $t$ must be a valid tag of $\sigma$ under $k_\mac = H(m)$ where $m = \decrypt(\sk, \sigma)$.

\begin{enumerate}
    \item How can I express that ``If $B$ knows $m$, then some knowledge extractor can recover $m$''?
    \item If $B$ does not know $m$, then $k_\mac$ is unknown and uniformly random. How can I construct a forgery adversary using $B$?
    \item How do I account for the scenario in which $c$ is invalid?
\end{enumerate}

\subsection{Plaintext awareness and OW-CPA imply OW-CCA}\label{sec:pa-and-owcpa-imply-owcca}
In this section we show that if a $\pke$ is both plaintext aware and \monospace{OW-CPA} secure, then it is \monospace{OW-CCA} secure.

\begin{theorem}\label{thm:pa-implies-cca}
    For every \monospace{OW-CCA} adversary $\mathcal{A}_\monospace{OW-CCA}$ with advantage $\epsilon_\monospace{OW-CCA}$, there exists an $\epsilon_K$ knowledge extractor $K$ and an \monospace{OW-CPA} adversary with advantage $\epsilon_\monospace{OW-CPA}$ such that

    \begin{equation*}
        \epsilon_\monospace{OW-CCA} \leq \epsilon_\monospace{OW-CPA} + q_D \cdot \epsilon_K
    \end{equation*}
\end{theorem}

\begin{proof}
    We will prove theorem \ref{thm:pa-implies-cca} by constructing an \monospace{OW-CPA} adversary $\mathcal{A}_\monospace{OW-CPA}$ that runs the \monospace{OW-CCA} adversary $\mathcal{A}_\monospace{OW-CCA}$ as a sub-routine. $\mathcal{A}_\monospace{OW-CPA}$ will answer $\mathcal{A}_\monospace{OW-CCA}$'s decryption query using the knowledge extractor.

    After receiving the security parameter $1^\lambda$ and public key $\pk$, $\mathcal{A}_\monospace{OW-CPA}$ initializes the hash tape $\mathcal{L}^H = \{\}$ to be an empty list, the runs $\mathcal{A}_\monospace{OW-CCA}$ until the sub-routine is waiting for the challenge ciphertext. During this phase:

    \begin{enumerate}
        \item When $\mathcal{A}_\monospace{OW-CCA}$ makes a hash query $h$, $\mathcal{A}_\monospace{OW-CPA}$ queries $\mathcal{O}^H$ to obtain the hash value $H(h)$, appends $(h, H(h))$ to $\mathcal{L}^H$, then answers with $H(h)$
        \item When $\mathcal{A}_\monospace{OW-CCA}$ makes a decryption query $c$, $\mathcal{A}_\monospace{OW-CPA}$ runs the knowledge extractor $m \leftarrow K(\mathcal{L}^H, C = \{\}, c)$, then answers with $m$
    \end{enumerate}

    After receiving $c^\ast$, $\mathcal{A}_\monospace{OW-CPA}$ passes $c^\ast$ to $\mathcal{A}_\monospace{OW-CCA}$, then continues simulating the \monospace{OW-CCA} game for the sub-routine.

    \begin{enumerate}
        \item Hash queries are answered in the same way as in the first phase
        \item When $\mathcal{A}_\monospace{OW-CCA}$ makes a decryption query $c$: \begin{itemize}
            \item If $c = c^\ast$, answer with $\bot$
            \item If $c \neq c^\ast$, run the knowledge extractor $m \leftarrow K(\mathcal{L}^H, C = \{c^\ast\}, c)$, then answer with $m$
        \end{itemize}
    \end{enumerate}

    We borrow the argument from \cite{bellare1998relations} to analyze how well $\mathcal{A}_\monospace{OW-CPA}$ simulates the decryption oracle. Let $q_D$ be the total number of decryption queries made throughout both phases and let $q_1$ denote the number of decryption queries made in phase 1. We can thus label the decryption queries by $(c_1, c_2, \ldots, c_{q_1}, c_{q_1 + 1}, \ldots, c_{q_D})$. Each decryption query corresponds to a plaintext awareness adversary $B_i$ playing an instance of the plaintext awareness game using $\mathcal{A}_\monospace{OW-CCA}$ as a sub-routine. Each $B_i$ answers hash queries from $\mathcal{A}_\monospace{OW-CCA}$ in the same way as described above. For $j < i$, $B_i$ answers the decryption query $c_j$ using what $K$ returns on $B_j$'s output. When $\mathcal{A}_\monospace{OW-CCA}$ makes the i-th decryption query $c_i$, $B_i$ outputs $c_i$ and halts. For $1 \leq j \leq q_1$, there is no ciphertext obtained without running the encryption routine, so $K$ is run with $C = \{\}$. For $q_1 < j \leq q_D$, $\mathcal{A}_\monospace{OW-CCA}$ has access to $c^\ast$, which is obtained without running the encryption routine, so $K$ is run with $C = \{c^\ast\}$.

    The simulated \monospace{OW-CCA} game deviates from the true \monospace{OW-CCA} game if and only if the knowledge extractor returns an incorrect decryption at one or more decryption queries. Since the probability of any one of decryption query being incorrect is bounded by $\epsilon_K$, the probability that at least one decryption query being incorrect is bounded by $q_D \cdot \epsilon_K$:

    \begin{equation*}
        \epsilon_\monospace{OW-CCA} - \epsilon_\monospace{OW-CPA}
        \leq q_D \cdot \epsilon_K
    \end{equation*}
\end{proof}

\bibliographystyle{alpha}
\bibliography{./references.bib}

\end{document}