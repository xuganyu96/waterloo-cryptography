\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Custom commands
\usepackage{mystyle}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{
    A survey of generic IND-CCA2 transformations
}
\author{
    Ganyu Xu
}
% Leave the date field empty to display the date of compilation
% \date{}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Preliminaries}
\subsection{Public-key encryption schemes}
A public key encryption scheme $\pke = (\keygen, \encrypt, \decrypt)$ is a collection of three routines. $\keygen(1^\lambda)$ takes the security parameteras input and returns a keypair $(\pk, \sk)$. $\encrypt(\pk, m)$ takes some public key and some plaintext message $m \in \mathcal{M}_\pke$ and output a ciphertext $c \in \mathcal{C}_\pke$. Where the encryption routine is probabilistic, we model the randomness using a coin $r \in \mathcal{R}$ such that $E(\pk, m; r)$ is deterministic with an explicit $r$. Finally, $\decrypt(\sk, c)$ uses the secret key to decrypt the ciphertext.

\subsubsection{Correctness}
Conventionally we require a $\pke$ to be perfectly correct. This means that for all possible key pairs $(\pk, \sk)$ and plaintexts $m$, the decryption routine always correctly inverts the encryption routine: $\decrypt(\sk, \encrypt(\pk, m)) = m$.

Where perfect correctness is not achieved, such as with most lattice-based encryption schemes, we need to account for the possiblity that decryption can fail. If under some keypair $(\pk, \sk)$, a plaintext-ciphertext pair $(m, c)$ is such that $c \leftsample \encrypt(\pk, m)$ is obtained from encrypting $m$ (probabilistically) but $m \neq \decrypt(\sk, c)$, we call it a decryption failure. For probabilistic encryption routines where the coin is uniformly sampled from the coin space, we can quantify the probability that $m$ triggers a decryption failure. From here, we can take the distribution of all keypairs and quantify the ``correctness'' of a (possibly imperfectly correct) encryption scheme. The following definition of $\delta$-correctness is directly taken from \cite{bos2018crystals}.

\begin{definition}[$\delta$-correctness]\label{def:delta-correctness}
    A probabilistic public-key encryption scheme $\pke = (\keygen, \encrypt, \decrypt)$ is $\delta$-correct if the expected maximal probability of decryption failure taken across the distribution of keypairs is at most $\delta$:

    \begin{equation*}
        E\left\lbrack\max_{m \in \mathcal{M}} P\left\lbrack
            \decrypt(\sk, \encrypt(\pk, m))
        \right\rbrack
        \right\rbrack \leq \delta
    \end{equation*}

    where the expectation is taken over the distribution of keypairs and the probability is taken over the distribution of coins.
\end{definition}

\cite{hofheinz2017modular} also defined an adversarial game in which the adversary's goal is to find some plaintext message to trigger a decryption failure. This adversarial game meaningfully models the real-world scenario in which decryption failure can reveal information about the secret key. Notice that when evaluating the win condition, the coin is uniformly random instead of being chosen by the adversary.

\begin{figure}[H]
    \center

    \begin{minipage}{0.5\textwidth}
        \begin{algorithm}[H]
            \caption{\monospace{CORS}}
            \begin{algorithmic}[1]
                \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                \State $m \leftsample A_\monospace{CORS}(1^\lambda, \pk, \sk)$
                \State \Return $\llbrack \decrypt(\sk, \encrypt(\pk, m)) \neq m \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    
    \caption{The correctness game \monospace{CORS}}\label{fig:cors-game}
\end{figure}

The definition of $\delta$-correctness sets an explicit upper bound on the probability that any plaintext triggers decryption failure. This means that even if the \monospace{CORS} adversary actually finds the message $m$ that is the most likely to trigger decryption failure, the probability of winning the \monospace{CORS} game is still upper-bounded by $\delta$.

\begin{lemma}
    If $\pke$ is $\delta$-correct, then for all \monospace{CORS} adversaries $A$, even computationally unbounded ones, the probability of winning the \monospace{CORS} game is at most $\delta$
\end{lemma}

The values of $\delta$ for Kyber are taken directly from \cite{avanzi2019crystals}

\begin{table}[H]
    \center
    \begin{tabular}{c|c}
        security level & $\delta$ \\
        \hline
        Kyber512 & $2^{-139}$ \\
        \hline
        Kyber768 & $2^{-164}$ \\
        \hline
        Kyber1024 & $2^{-174}$ \\
    \end{tabular}
    \caption{Concrete $\delta$ for Kyber}\label{tbl:kyber-delta-vals}
\end{table}

\subsubsection{Security}
An one-way adversary $A = (A_1, A_2)$ consists of two sub-routines $A_1$ and $A_2$. $s \leftsample A_1^{\mathcal{O}_1}(1^\lambda, \pk)$ takes the security parameter, some public-key, access to some oracle(s) $\mathcal{O}_1$, and outputs some intermediate state $s$. $\hat{m} \leftarrow A_2^{\mathcal{O}_2}(1^\lambda, \pk, c^\ast)$ resumes from the output of $A_1$ and takes some challenge ciphertext, then tries to guess the corresponding decryption.

The advantage $\monospace{Adv}_\monospace{OW-ATK}(A)$ of an \monospace{OW-ATK} adversary is the probability that its guess is correct.

\begin{definition}
    A $\pke$ is \monospace{OW-ATK} secure if for all efficient adversaries $A$, the advantage in the \monospace{OW-ATK} game is neligigble with respect to the security parameter:

    \begin{equation*}
        \monospace{Adv}_\monospace{OW-ATK}(A) \leq \operatorname{negl}(\lambda)
    \end{equation*}
\end{definition}

An \textbf{indistinguishability} adversary $A = (A_1, A_2)$ similarly consists of two sub-routines. The first sub-routine adversarially chooses two distinct plaintext messages, and the second sub-routine tries to distinguish which of the two plaintext messages is the decryptino of the challenge encryption. The advantage of an indistinguishability adversary is defined by $\monospace{Adv}_\monospace{IND-ATK}(A) = P[\hat{b} = b] - \frac{1}{2}$

\begin{definition}
    A $\pke$ is \monospace{IND-ATK} secure if for all efficient adversaries $A$, the advantage in the indistinguishability game is negligible with respect to the security parameter

    \begin{equation*}
        \monospace{Adv}_\monospace{IND-ATK}(A) \leq \operatorname{negl}(\lambda)
    \end{equation*}
\end{definition}

The security games are described in details in figure \ref{fig:sec-games}

\begin{figure}[H]
    \center
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{\monospace{OW-ATK} game}\label{alg:ow-atk-game}
            \begin{algorithmic}[1]
                \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                \State $s \leftsample A_1^{\mathcal{O}_1}(1^\lambda, \pk)$
                \State $m^\ast \leftsample \mathcal{M}$
                \State $c^\ast \leftsample \encrypt(\pk, m^\ast)$
                \State $\hat{m} \leftarrow A_2^{\mathcal{O}_2}(1^\lambda, \pk, s, c^\ast)$
                \State \Return $\llbrack \hat{m} = m^\ast\rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.5\textwidth}
        \begin{algorithm}[H]
            \caption{\monospace{IND-ATK} game}\label{alg:ind-atk-game}
            \begin{algorithmic}[1]
                \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                \State $(m_0, m_1) \leftsample A_1^{\mathcal{O}_1}(1^\lambda, \pk)$
                \State $b \leftsample \{0,1\}$
                \State $c^\ast \leftsample \encrypt(\pk, m_b)$
                \State $\hat{b} \leftarrow A_2^{\mathcal{O}_2}(1^\lambda, \pk, s, c^\ast)$
                \State \Return $\llbrack \hat{b} = b \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{The indistinguishability security game}\label{fig:sec-games}
\end{figure}

The capabilities of the adveraries are modeled using different collections of oracles. In standard security requirements, adversaries with access to no additional oracles can only mount chosen plaintex attacks (CPA), adversaries with access to decryption oracle $\mathcal{O}^\decrypt$ only before the receiving challenge ciphertext can mount non-adaptive chosen ciphertext attacks (CCA1), adversaries with access to decryption oracle both before and after receiving the challenge ciphertext can mount adaptive chosen ciphertext attacks (CCA2).

\cite{hofheinz2017modular} also defined two non-standard oracles and the corresponding attacks. The plaintext checking oracle $\pco(m, c)$ returns $1$ if $m$ is a decryption of $c$ and $0$ otherwise. The ciphertext validation oracle $\cvo(c)$ returns $1$ if $c$ is a valid ciphertext and $0$ otherwise.

\begin{figure}[H]
    \center

    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\pco(m, c)$}\label{alg:pco}
            \begin{algorithmic}
                \State \Return $\llbrack \decrypt(\sk, c) = m \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hfill
    \begin{minipage}{0.49\textwidth}
        \begin{algorithm}[H]
            \caption{$\cvo(c)$}\label{alg:cvo}
            \begin{algorithmic}[1]
                \State \Return $\llbrack \decrypt(\sk, c) \in \mathcal{M} \rrbrack$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}

    \caption{$\pco$ and $\cvo$}\label{fig:pco-and-cvo}
\end{figure}

Here is an overview of the various kinds of attacks and their associated oracles

\begin{table}[H]
    \center
    \begin{tabular}{c|c|c}
        \monospace{ATK} & $\mathcal{O}_1$ & $\mathcal{O}_2$ \\
        \hline
        \monospace{CPA} & \multicolumn{2}{|c|}{$-$} \\
        \hline
        \monospace{CCA1} & $\mathcal{O}^\decrypt$ & - \\
        \hline
        \monospace{CCA2} & \multicolumn{2}{|c|}{$\mathcal{O}^\decrypt$} \\
        \hline
        \monospace{PCVA} & \multicolumn{2}{|c|}{$\pco, \cvo$} \\
        \hline
        \monospace{PCA} & \multicolumn{2}{|c|}{$\pco$} \\
        \hline
        \monospace{VA} & \multicolumn{2}{|c|}{$\cvo$} \\
    \end{tabular}
    \caption{Attacks and associated oracle access}
\end{table}

\cite{hofheinz2017modular} stated a ``well-known'' result that the \monospace{IND-CPA} security of a scheme with a large message space implies \monospace{OW-CPA} security:

\begin{theorem}\label{thm:ind-cpa-implies-ow-cpa}
    For every \monospace{IND-CPA} adversary $B$ against some $\pke$, there exists an \monospace{OW-CPA} adversary $A$ against the same $\pke$ such that:

    \begin{equation*}
        \monospace{Adv}_\monospace{OW-CPA}(A) = \frac{1}{\norm{\mathcal{M}}} + \monospace{Adv}_\monospace{IND-CPA}(B)
    \end{equation*}
\end{theorem}

\subsubsection{Spread and rigidity}
The spread of a public key encryption scheme measures the diffusion the encryption routine's output. The higher the spread, the lower the probability of obtaining any specific ciphertext.

\begin{definition}[$\gamma$-spread]\label{def:gamma-spread}
    For a given keypair $(\pk, \sk)$ and plaintext message $m \in \mathcal{M}$, the \emph{min-entropy} of the encryption routine is:
    
    $$\operatorname{min-entropy}(\pk, m) := -\log_2\left( 
        \max_{c \in \mathcal{C}} P\left\lbrack
            c = \encrypt(\pk, m)
        \right\rbrack
    \right) $$

    A $\pke$ has $\gamma$-spread if for all keypairs $(\pk, \sk)$ and plaintext $m \in \mathcal{M}$:

    $$
        \operatorname{min-entropy}(\pk, m) \leq \gamma
    $$
\end{definition}

Having $\gamma$ sperad means that for any keypair $(\pk, \sk)$, plaintext $m$, and ciphertext $c$:

$$
P\left\lbrack c = \encrypt(\pk, m) \right\rbrack \leq 2^{-\lambda}
$$

Finally, \emph{rigidity} conveys the idea that a ciphertext cannot be perturbed without becoming either invalid or decrypting to another plaintext

\begin{definition}[rigidity]\label{def:rigidity}
    $\pke(\keygen, \encrypt, \decrypt)$ is \emph{rigid} if for all keypairs $(\pk, \sk)$ and ciphertext $c$, either $\decrypt(\sk, c) = \bot$ or $\encrypt\left(\pk, \decrypt(\sk, c)\right) = c$
\end{definition}

\section{Modular Fujisaki-Okamoto transformation}
The Fujisaki-Okamoto transformation \cite{fujisaki1999secure} and its KEM variations \cite{hofheinz2017modular} achieve security against adaptive chosen-ciphertext attacks through \emph{de-randomization} and \emph{re-encryption}. In particular, the modular FO transformation contains two steps. First, the 

\bibliographystyle{alpha}
\bibliography{./references.bib}

\end{document}