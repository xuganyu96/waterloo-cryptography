\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}


\title{A survey of IND-CCA constructions}
\author{Ganyu (Bruce) Xu (g66xu)}
\date{CO 789, Winter 2024}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Introduction}
Indistinguishability under (adaptive) chosen-ciphertext attack (IND-CCA2) is widely recognized as the desirable security notion for public-key cryptography. However, directly achieving IND-CCA2 security is difficult. Previous attempts at deploying public-key cryptography in production, such as the usage of RSA PKCS1 v1.5 in early versions of SSl/TLS, were found to be vulnerable to adaptive chosen-ciphertext attacks.

Instead of directly constructing IND-CCA2 secure cryptosystem from NP-hard problems, recent works approached this problem by proposing generic transformation that take cryptographic primitives of lesser strengths (e.g. OW-CPA, IND-CPA) and produce encryption schemes that lose only a negligible amount of security. One such transformation was proposed by Fujisaki and Okamoto in 1999 and later improved by Hofheinz, Hovelmann, and Kiltz in 2017. With simple construction and robust security reduction, the FO transformation is adopted by submissions to NIST's post-quantum cryptography competition (notably by Kyber, which has been standardized in FIPS 203 in 2024).

In this paper, we will review the constructions of the Fujisaki-Okamoto transformation and its variations. We will also review their security results, including the techniques used in the security reduction. Finally, we will discuss open problems and propose some optimization.

\section{Preliminaries}
% TODO: from IND-CPA to OW-CPA

\subsection{Spread and correctness}
The spread of measures the randomness of ciphertext in a probabilistic encryption scheme, where the randomness of the encryption routine is determined by a random coin $r \leftsample \text{Coin}$ from the coin space.

\begin{definition}[$\gamma$-spread]
    The spread $\gamma$ of an asymmetric encryption scheme $(\operatorname{KeyGen}, E, D)$ for some fixed public key $\text{pk}$ and plaintext $m$ is defined by

    \begin{equation*}
        \gamma(\text{pk}, m) = -\log{\Norm{E_\text{pk}(m)}_\infty}
    \end{equation*}

    Where $\Norm{E_\text{pk}(m)}_\infty$ is the min-entropy of the ciphertext with respect to the coin:

    \begin{equation*}
        \Norm{E_\text{pk}(m)}_\infty 
        = \max_{c \in \mathcal{C}} P[E_\text{pk}(m) = c]
    \end{equation*}
\end{definition}

\begin{definition}[correctness]
    A public-key encrpytion scheme $(\operatorname{KeyGen}, E, D)$ is $\delta$-correct if across all possible keypairs and messages, the probability of decryption error is at most $\delta$:

    \begin{equation*}
        \max_{
            m \in \mathcal{M},
            (\text{pk}, \text{sk}) \leftsample \operatorname{KeyGen}()
        } P[D_\text{sk}(E_\text{pk}(m)) \neq m]
        \leq \delta
    \end{equation*}
\end{definition}

\subsection{Difference lemma}
The difference lemma is used extensively in the sequence of games to estimate the loss of security when one game is transformed into another

\begin{lemma}[Difference lemma]
    Let $A, B, F$ be events defined on the same probability space. If $P[A \cap \neg F] = P[B \cap \neg F]$, then $P[A] - P[B] \leq P[F]$
\end{lemma}

\begin{proof}
    \begin{equation*}
        \begin{aligned}
            P[A] - P[B] &= (P[A \cap F] + P[A \cap \neg F]) 
                - (P[B \cap F] + P[B \cap \neg F]) \\
            &= (P[A \cap F] - P[B \cap F]) 
                + (P[A \cap \neg F] - P[B \cap \neg F]) \\
            &= P[A \cap F] - P[B \cap F] \\
            &\leq P[A \cap F] \\
            &\leq P[F]
        \end{aligned}
    \end{equation*}
\end{proof}

In the context of security reduction using sequence of game, the difference lemma is invoked with event $A$ and $B$ set to "adversary winning one game" and "adversary winning another game", and event $F$ set to the event that would cause the two games two diverge. If the diverging event $F$ does not happen, then the two games are identical to each other, so the advantage of the adversary remains the same across the two games; if the diverging event $F$ happens, then the advantage of the adversary does not change by more than the probability of the diverging event $F$.

\subsection{IND-CPA to OW-CPA}
It is trivially true that if a public-key encryption scheme is not one-way secure, then it is not indistinguishable. The converse if also almost true, with the caveat that the message space must be sufficiently large: 

\begin{lemma}
    Let $(\operatorname{KeyGen}, E, D)$ be a public-key encryption scheme with a finite message space $\mathcal{M}$. For every IND-CPA adversary $A$, there exists an OW-CPA adversary $B$ such that

    \begin{equation*}
        \epsilon_\text{OW-CPA} = \epsilon_\text{IND-CPA} + \frac{1}{\norm{\mathcal{M}}}
    \end{equation*}
\end{lemma}

\section{Related works}
    Key encapsulation mechanisms (KEM) usually have weaker security requirements than public-key encryption schemes (PKE) thanks to the fact that properly designed KEMs obfuscate the plaintext through a key-derivation function (which is usually a hash function and thus a random oracle under the RO assumption) in the decryption routine. As a result, we can implement a simple IND-CCA2 KEM using an IND-CCA2 PKE:

    \begin{multicols}{3}
        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{KeyGen}
            $(\text{pk}, \text{sk}) \leftsample \operatorname{KeyGen}()$ \;
            \Return{$(\text{pk}, \text{sk})$}
        \end{algorithm}

        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{Encap}
            \KwIn{$\text{pk}$}
            $m \leftsample \mathcal{M}$\;
            $c \leftsample E(\text{pk}, m)$\;
            $K \leftarrow H(m, c)$\;
            \Return{$(c, K)$}\;
        \end{algorithm}

        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{Decap}
            \KwIn{$\text{sk}, c \in \mathcal{C}$}
            $\hat{m} \leftarrow D(\text{sk}, c)$\;
            $\hat{K} \leftarrow H(\hat{m}, c)$\;
            \Return{$\hat{K}$}\;
        \end{algorithm}
    \end{multicols}

    It is straightforward to simulate the KEM game using a PKE adversary. The PKE adversary samples two random messages $(m_0, m_1) \leftsample \mathcal{M}$ and obtains the challenge encryption for one of them $c^\ast \leftarrow E(\text{pk}, m_b)$. The PKE adversary then computes $K^\ast \leftarrow H(c^\ast, m_0)$ and passes $(c^\ast, K^\ast)$ as the challenge encapsulation to the KEM adversary. If $c^\ast$ is an encryption of $m_0$, then $K^\ast$ is pseudorandom, otherwise under the random oralce model, $K^\ast$ is truly random from the perspective of the KEM adversary. Therefore, $\epsilon_\text{PKE} = \epsilon_\text{KEM}$.

    Using IND-CCA2 PKE as an IND-CCA2 KEM has been in production for a long time. For example, TLS 1.2 \cite{dierks2008rfc} offers this implementation for key exchange using RSA-OAEP\cite{bellare1995optimal} as the underlying IND-CCA2 PKE. The key exchange protocol proceeds as follows:

    \begin{enumerate}
        \item Server sends its public key through the X.509 certificate
        \item Client samples a master secret, encrypts the secret using server's public key, then sends the ciphertext to the server
        \item Server decrypts the ciphertext to obtain the master secret
    \end{enumerate}

    This approach to key exchange has since been deprecated, and RSA is no longer supported for key exchange starting with TLS 1.3. In addition to the difficulty of implementing RSA correctly and securely (RSA is notoriously hard to implement without side-channel vulnerabilities), using the server's long-term keypair for establishing common secrets fails to provide forward secrecy, meaning that if the long-term key is compromised, all prior communications can be trivially decrypted.

    While the modern approach is to use ephemeral Diffie-Hellman (with either prime field or elliptic curve), it is difficult to adapt this approach to the post-quantum setting. Instead, post-quantum key exchange usually builds an IND-CCA2 KEM, then perform the key exchange using ephemeral keypairs. At each session's handshake, the client generates the a new keypair and sends the public key to the server. The server uses the public key to run the encapsulation routine and sends back the ciphertext. Finally, the client runs the decapsulation routine on the ciphertext to recover the shared secret.

\section{Fujisaki-Okamoto transformation and variations}
In 1999, Fujisaki and Okamoto \cite{fujisaki1999secure} proposed a generic transformation that outputs an IND-CCA2-secure public-key encryption scheme using an IND-CPA symmetric cipher, an OW-CPA asymmetric cipher, and two hash functions. Later on in 2017, Hofheinz, Hovelmann, and Kiltz \cite{hofheinz2017modular} improved on the security of the Fujisaki-Transformation and adapted the original approach to constructing IND-CCA2 KEMs. In this section, we will give a quick overview of the individual transformations and their security results. We will then discuss the techniques used in the security reduction. Finally, we will provide a sketch of the actual proof.

\subsection{An overview of transformed routines and security results}
The original 1999 Fujisaki-Okamoto transformation takes as input a symmetric cipher $(E^\text{sym}, D^\text{sym})$, an asymmetric cipher $(\operatorname{KeyGen}, E^\text{asym}, D^\text{asym})$, a key derivation function (aka a hash function) $G: \mathcal{M}^\text{asym} \rightarrow \mathcal{K}^\text{sym}$, and a hash functino $H: \{0, 1\}^\ast \rightarrow \text{Coin}^\text{asym}$.

Specifically, the asymmetric cipher is assumed to be probabilistic, but with pseudorandomness seeded on some coin $r \in \text{Coin}^\text{asym}$. When $E^\text{asym}$ is called without specifying a value for coin, it is assumed that a coin is uniformly sampled from the coin space and passed in as the pseudorandom seed:

$$
    c \leftsample E^\text{asym}(\text{pk}, m) 
    \Leftrightarrow 
    c \leftarrow E^\text{asym}(\text{pk}, m, r \leftsample \text{Coin})
$$

The output of the transformation is a public-key encryption scheme $(\operatorname{KeyGen}, E^\text{hy}, D^\text{hy})$. Note that the key generation routine is exactly the same as the input asymmetric cipher's routine, so no distinction of notation is needed. The encryption and decryption routines are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Hybrid encryption $E^\text{hy}$}
        \KwIn{$\text{pk}, m \in \mathcal{M}^\text{sym}$}
        $\sigma \leftsample \mathcal{M}^\text{asym}$\;
        $a \leftarrow G(\sigma)$; $c \leftarrow E^\text{sym}_a(m)$\;
        $r \leftarrow H(\sigma, c)$;
        $e \leftarrow E^\text{asym}(\text{pk}, m, r)$\;
        \Return{$(c, e)$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Hybrid decryption $D^\text{hy}$}
        \KwIn{$\text{sk}, c \in \mathcal{C}^\text{sym}, e \in \mathcal{C}^\text{asym}$}
        $\hat{\sigma} \leftarrow D^\text{asym}(\text{sk}, e)$\;
        $\hat{r} \leftarrow H(\hat{\sigma}, c)$\;
        \If{
            $E^\text{asym}(\text{pk}, \hat{\sigma}, \hat{r}) \neq e$
        }{
            \Return{$\bot$}; \tcp*[h]{the "re-encryption"}
        }
        $\hat{a} \leftarrow G(\hat{\sigma})$\;
        $\hat{m} \leftarrow D^\text{sym}_{\hat{a}}(c)$\;
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

\begin{theorem}[Security result for $(E^\text{hy}, D^\text{hy})$]
    If the input asymmetric cipher has $\gamma$ spread, then for every IND-CPA adversary $\mathcal{A}^\text{sym}_\text{IND-CPA}$ against the underlying symmetric cipher with advantage $\epsilon^\text{sym}$ and OW-CPA adversary $\mathcal{A}^\text{asym}_\text{OW-CPA}$ against the input asymmetric cipher with advantage $\epsilon^\text{asym}$, there exists an IND-CCA2 adversary with against the hybrid scheme making $q_H$ hash queries and $q_D$ decryption queries such that:

    \begin{equation*}
        \epsilon^\text{hy} 
        \leq q_D2^{-\gamma} 
            + \epsilon^\text{sym} 
            + q_H\epsilon^\text{asym}
    \end{equation*}
\end{theorem}

Hofheinz, Hovenmann, and Kiltz pointed out in their 2017 paper a number of drawbacks of the original FO transformation:

\begin{enumerate}
    \item Decryption error, which is especially possible with lattice-based schemes, is not accounted for
    \item the $q_H\epsilon^\text{asym}$ term causes security to be non-tight, which have implications when choosing the security parameters
\end{enumerate}

In their proposals, IND-CCA2 security is achieved through a two-step transformation. First, an OW-CPA asymmetric scheme is transformed into an OW-PCVA asymmetric scheme. The OW-PCVA scheme is then transformed into an IND-CCA2 KEM. Here PCVA refers to the adversary's ability to access some plaintext-checking oracle and some ciphertext validation oracle. Although PCVA is a non-standard security definition, it is entirely contained within the two-step transformation and serves only as an intermediary step.

Neither the OW-PCVA nor the IND-CCA transformation makes use of any symmetric cipher, so we ditch the distinction. The OW-PCVA transformation takes as input an asymmetric cipher $(E, D)$ and a hash function $G: \mathcal{M} \rightarrow \text{Coin}$. The transformed encryption and decryption routines $(E^T, D^T)$ are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA $E^T$}
        \KwIn{$\text{pk}, m \in \mathcal{M}$}
        $r \leftarrow G(m)$\;
        $c \leftarrow E(\text{pk}, m, r)$\;
        \Return{$c$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA $D^T$}
        \KwIn{$\text{sk}, c \in \mathcal{C}$}
        $\hat{m} \leftarrow D(\text{sk}, c)$\;
        $\hat{r} \leftarrow G(\hat{m})$\;
        \If{
            $E(\text{pk}, \hat{m}, \hat{r}) \neq c$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$};
    \end{algorithm}
\end{multicols}

Depending on whether the implementation chooses implicit or explicit rejection of invalid ciphertext for the final KEM, the second transformation has slightly different key generation and decryption routine. The explicit rejection KEM is denoted by $U^\bot$, and its key generation is identical to the input asymmetric cipher.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{$U^\bot$ Encap}
        \KwIn{$\text{pk}$}
        $m \leftsample \mathcal{M}$\;
        $c \leftarrow E^T(\text{pk}, m)$\;
        $K \leftarrow H(m, c)$ \tcp*[h]{H is a hash function}\;
        \Return{$(c, K)$}
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{$U^\bot$ Decap}
        \KwIn{$c \in \mathcal{C}, \text{sk}$}
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $m = \bot$
        }{
            \Return{$\bot$};
        }
        \Return{$H(\hat{m}, c)$}
    \end{algorithm}
\end{multicols}

On the other hand, the implicit rejection KEM, denoted by $U^{\not\bot}$, generate a random message $m^\prime \leftsample \mathcal{M}$ as the fake input to $H$ when the ciphertext is invalid

\begin{multicols}{3}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{KeyGen}
        $\text{pk}, \text{sk} \leftsample \operatorname{KeyGen}()$\;
        $m^\prime \leftsample \mathcal{M}$\;
        \Return{$(\text{pk}, (\text{sk}, m^\prime))$}\;
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Encap}
        $m \leftsample \mathcal{M}$\;
        $c \leftarrow E^T(\text{pk}, m)$\;
        $K \leftarrow H(m, c)$\;
        \Return{$(c, K)$}
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Decap}
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $m = \bot$
        }{
            \Return{$H(m^\prime, c)$};
        }
        \Return{$H(\hat{m}, c)$}
    \end{algorithm}
\end{multicols}

The security result is similarly expressed in two theorems:

\begin{theorem}
    If the input asymmetric scheme is $\delta$-correct and $\gamma$-spread, then for every OW-PCVA adversary that issues at most $q_G$ hash queries and $q_V$ ciphertext validation queries with advantage $\epsilon^T$, there exists an IND-CPA adversary against the underlying asymmetric scheme with advantage $\epsilon$ such that

    \begin{equation*}
        \epsilon^T \leq q_G \cdot \delta + q_V \cdot 2^{-\gamma} 
            + \frac{2q_G + 1}{\norm{\mathcal{M}}}
            + 3\epsilon
    \end{equation*}
\end{theorem}

\begin{theorem}
    For every IND-CCA2 adversary against the $U^\bot$ KEM with advantage $\epsilon^{U^\bot}$, there exists an OW-PCVA adversary against the input scheme $(E^T, D^T)$ with advantage $\epsilon^T$ such that

    \begin{equation*}
        \epsilon^{U^\bot} \leq \epsilon^T
    \end{equation*}
\end{theorem}

\begin{theorem}
    For every IND-CCA2 adversary against the $U^{\not\bot}$ KEM that issues $q_H$ hash queries with advantage $\epsilon^{U^{\not\bot}}$, there exists an OW-PCVA adversary against the input scheme $(E^T, D^T)$ with advantage $\epsilon^T$ such that

    \begin{equation*}
        \epsilon^{U^{\not\bot}} \leq \epsilon^T + \frac{q_H}{\norm{\mathcal{M}}}
    \end{equation*}
\end{theorem}

\subsection{A discussion of techniques}

\subsection{A sketch of proof}

\section{Future works on generic IND-CCA transformation}

\bibliographystyle{plain}
\bibliography{./references.bib}

\end{document}