%%%% 1. DOCUMENTCLASS %%%%
% \documentclass[journal=tches,submission,notanonymous]{iacrtrans}
\documentclass[floatrow,journal=tches,submission]{iacrtrans}
%%%% NOTES:
% - Change "journal=tosc" to "journal=tches" if needed
% - Change "submission" to "final" for final version
% - Add "notanonymous" to reveal authors
% - Add "spthm" for LNCS-like theorems


%%%% 2. PACKAGES %%%%
\usepackage{algorithm}
\usepackage{algpseudocode}
% \usepackage[demo]{graphicx}

%%%% 3. AUTHOR, INSTITUTE %%%%
\author{
    Ganyu Xu\inst{1}
    \and Guang Gong\inst{1}
    \and Kalikinkar Mandal\inst{2}
}
\institute{
  University of Waterloo, Waterloo, Canada, \email{{g66xu,ggong}@uwaterloo.ca}
  \and
  University of New Brunswick, New Brunswick, Canada, \email{kmandal@unb.ca}
}
%%%% NOTES:
% - We need a city name for indexation purpose, even if it is redundant
%   (eg: University of Atlantis, Atlantis, Atlantis)
% - \inst{} can be omitted if there is a single institute,
%   or exactly one institute per author

% Custom commands
\newcommand{\pke}{\texttt{PKE}}
\newcommand{\keygen}{\texttt{KeyGen}}
\newcommand{\encrypt}{\texttt{Enc}}
\newcommand{\decrypt}{\texttt{Dec}}
\newcommand{\kem}{\texttt{KEM}}
\newcommand{\encap}{\texttt{Encap}}
\newcommand{\decap}{\texttt{Decap}}
\newcommand{\etm}{\texttt{EtM}}  % encrypt-then-mac
\newcommand{\mac}{\texttt{MAC}}
\newcommand{\sign}{\texttt{Sign}}
\newcommand{\verify}{\texttt{Verify}}
\newcommand{\pk}{\texttt{pk}}
\newcommand{\sk}{\texttt{sk}}
\newcommand{\pco}{\texttt{PCO}}
\newcommand{\cvo}{\texttt{CVO}}
\newcommand{\leftsample}{\stackrel{\$}{\leftarrow}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newcommand{\norm}[1]{\left\lvert #1 \right\rvert}
\newcommand{\adv}{\texttt{Adv}}
\newcommand{\fotplus}{\texttt{FOT+}}

%%%% 4. TITLE %%%%
\title{
Faster generic IND-CCA2 secure KEM using ``encrypt-then-MAC''}
%%%% NOTES:
% - If the title is too long, or includes special macro, please
%   provide a "running title" as optional argument: \title[Short]{Long}
% - You can provide an optional subtitle with \subtitle.

\begin{document}

\maketitle


%%%% 5. KEYWORDS %%%%
\keywords{
    Key encapsulation mechanism, 
    post-quantum cryptography,
    lattice cryptography,
    Fujisaki-Okamoto transformation
}


%%%% 6. ABSTRACT %%%%
\begin{abstract}
  The modular Fujisaki-Okamoto (FO) transformation takes public-key encryption with weaker security and constructs a key encapsulation mechanism (KEM) with indistinguishability under adaptive chosen ciphertext attacks. While the modular FO transform enjoys tight security bound and quantum resistance, it also suffers from computational inefficiency and vulnerabilities to side-channel attacks due to using de-randomization and re-encryption for providing ciphertext integrity. In this work, we propose an alternative KEM construction that achieves ciphertext integrity using a message authentication code (MAC) and instantiate a concrete instance using Kyber. Our experimental results showed that where the encryption routine incurs heavy computational cost, replacing re-encryption with MAC provides substantial performance improvements at comparable security level.
\end{abstract}


%%%% 7. PAPER CONTENT %%%%
\section{Introduction}
The Fujisaki-Okamoto transformation \cite{fujisaki1999secure} is a generic construction that takes cryptographic primitives of lesser security and constructs a public-key encryption scheme with indistinguishability under adaptive chosen ciphertext attacks. Later works \cite{hofheinz2017modular} extended the original transformation to the construction of key encapsulation mechanism, which has been adopted by many post-quantum schemes such as Kyber \cite{bos2018crystals}, FrodoKEM \cite{bos2016frodo}, and SABER \cite{d2018saber}.

The current state of the FO transformation enjoys proven tight security bound and quantum resistance \cite{hofheinz2017modular}, but also leaves many deficiencies to be improved on. One such shortcoming is the use of re-encryption for providing ciphertext integrity \cite{bernstein2018towards}, which requires the decapsulation routine to run the encryption routine as a subroutine. In many post-quantum schemes, such as Kyber, the encryption routine is substantially more expensive than the decryption routine, so running the encryption routine in the decapsulation routine inflates the computational cost of the decapsulator. In addition, running the encryption as a subroutine introduces risks of side-channel vulnerabilities that may expose the plaintext or the secret key \cite{ravi2019generic}\cite{ueno2022curse}.

The problem of ciphertext integrity was solved in symmetric cryptography: given a semantically secure symmetric cipher and an existentially unforgeable message authentication code, combining them using ``encrypt-then-mac'' provides authenticated encryption \cite{bellare2000authenticated}. We took inspiration from this strategy and applied a similar technique to transform an OW-PCA secure public-key encryption scheme into an IND-CCA2 secure key encapsulation mechanism. Using a message authentication code for ciphertext integrity replaces the re-encryption step in decryption with the computation of an authenticator, which offers significant performance improvements while maintaining comparable level of security.

The main challenge in applying ``encrypt-then-mac'' to public-key cryptography is the lack of a pre-shared symmetric key. We proposed to derive the symmetric key by hashing the plaintext message. In section \ref{sec:main-results}, we prove that under the random oracle model, if the input public-key encryption scheme is one-way secure against plaintext-checking attack and the input message authentication code is one-time existentially unforgeable, then the transformed key encapsulation mechanism is IND-CCA2 secure.

In section \ref{sec:experimental-results}, we instantiate concrete instances of our constructions by combining Kyber with GMAC and Poly1305. Our experimental results showed that replacing re-encryption with computing authenticator leads to significant performance improvements in the decapsulation routine while incurring only minimal runtime overhead in the encapsulation routine and a small increase in ciphertext size.

\section{Preliminaries and previous results}

\subsection{Public-key encryption scheme}
A public key encryption scheme $\pke$ is a collection of three routines $(\keygen, \encrypt, \decrypt)$ defined over some message space $\mathcal{M}$ and some ciphertext space $\mathcal{C}$. Where the encryption routine is probabilistic, the source of randomness is denoted by the coin space $\mathcal{R}$.

The encryption routine $\encrypt(\pk, m)$ takes a public key, a plaintext message, and outputs a ciphertext $c \in \mathcal{C}$. Where the encryption routine is probabilistic, specifying a pseudorandom seed $r \in \mathcal{R}$ will make the encryption routine behave deterministically. The decryption routine $\decrypt(\sk, c)$ takes a secret key, a ciphertext, and outputs the decryption $\hat{m}$ if the ciphertext is valid. Some PKE will explicitly reject invalid ciphertext, in which case the decryption routine will output the rejection symbol $\bot$

We discuss the security of a $\pke$ using the sequence of games described in \cite{shoup2004sequences}. Specifically, we first define the $\texttt{OW-ATK}$ as they pertain to a public key encryption scheme. In later section we will define the $\texttt{IND-CCA}$ game as it pertains to a key encapsulation mechanism.

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{
                    The $\texttt{OW-ATK}$ game
                }\label{alg:pke-ow-atk-game}
                \begin{algorithmic}[1]
                    \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                    \State $m^\ast \leftsample \mathcal{M}$
                    \State $c^\ast \leftsample \encrypt(\pk, m^\ast)$
                    \State $\hat{m} \leftsample \mathcal{A}^{\mathcal{O}_\texttt{ATK}}(1^\lambda, \pk, c^\ast)$
                    \State \Return $\llbrack m^\ast = \hat{m} \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }
        {\caption{The \texttt{OW-ATK} game}}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{$\pco(m \in \mathcal{M}, c \in \mathcal{C})$}\label{alg:pco}
                \begin{algorithmic}[1]
                    \State \Return $\llbrack \decrypt(\sk, c) = m \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }
        {\caption{Plaintext-checking oracle}}
    \end{floatrow}
    \label{fig:pco-and-cvo}
\end{figure}

In the \texttt{OW-ATK} game (see figure \ref{alg:pke-ow-atk-game}), an adversary's goal is to recover the decryption of a randomly generated ciphertext. A challenger randomly samples a keypair and a challenge plaintext $m^\ast$, encrypts the challenge plaintext $c^\ast \leftsample \encrypt(\pk, m^\ast)$, then gives $\pk$ and $c^\ast$ to the adversary $A$. The adversary $A$, with access to some oracle $\mathcal{O}_\texttt{ATK}$, outputs a guess decryption $\hat{m}$. $A$ wins the game if its guess $\hat{m}$ is equal to the challenge plaintext $m^\ast$. The \textit{advantage} $\adv_\texttt{OW-ATK}$ of an adversary in this game is the probability that it wins the game:

\begin{equation*}
    \adv_\texttt{OW-ATK}(A) = P\left[
        A(\pk, c^\ast) = m^\ast \vert
        (\pk, \sk) \leftsample \keygen() ;
        m^\ast \leftsample \mathcal{M};
        c^\ast \leftsample \encrypt(\pk, m^\ast)
    \right]
\end{equation*}

The capabilities of the oracle $\mathcal{O}_\texttt{ATK}$ depends on the choice of security goal $\texttt{ATK}$. Particularly relevant to our result is security against plaintext-checking attack (PCA), for which the adversary has access to a plaintext-checking oracle (PCO) (see figure \ref{alg:pco}). A PCO takes as input a plaintext-ciphertext pair $(m, c)$ and returns \texttt{True} if $m$ is the decryption of $c$ or \texttt{False} otherwise.

\subsection{Key encapsulation mechanism (KEM)}
A key encapsulation mechanism is a collection of three routines $(\keygen, \encap, \decap)$ defined over some ciphertext space $\mathcal{C}$ and some key space $\mathcal{K}$. The key generation routine takes the security parameter $1^\lambda$ and outputs a keypair $(\pk, \sk) \leftsample \keygen(1^\lambda)$. $\encap(\pk)$ is a probabilistic routine that takes a public key $\pk$ and outputs a pair of values $(c, K)$ where $c \in \mathcal{C}$ is the ciphertext (also called encapsulation) and $K \in \mathcal{K}$ is the shared secret (also called session key). $\decap(\sk, c)$ is a deterministic routine that takes the secret key $\sk$ and the encapsulation $c$ and returns the shared secret $K$ if the ciphertext is valid. Some KEM constructions use explicit rejection, where if $c$ is invalid then $\decap$ will return a rejection symbol $\bot$; other KEM constructions use implicit rejection, where if $c$ is invalid then $\decap$ will return a fake session key that depends on the ciphertext and some other secret values.

The IND-CCA security of a KEM is defined by an adversarial game in which an adversary's goal is to distinguish pseudorandom shared secret (generated by running the $\encap$ routine) and a truly random value.

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{
                    \texttt{IND-CCA} game for \kem
                }\label{alg:kem-ind-cca-game}
                
                \begin{algorithmic}[1]
                    \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                    \State $(c^\ast, K_0) \leftsample \encap(\pk)$
                    \State $K_1 \leftsample \mathcal{K}$
                    \State $b \leftsample \{0, 1\}$
                    \State $\hat{b} \leftsample A^{\mathcal{O}_\decap}(
                        1^\lambda, \pk, c^\ast, K_b
                    )$
                    \State \Return $\llbrack \hat{b} = b \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }{\caption{The \texttt{KEM-IND-CCA2} game}}
        \ffigbox{
            \begin{algorithm}[H]
            \caption{
                $\mathcal{O}_\decap(c)$
            }
            \begin{algorithmic}[1]
                \State \Return $\decap(\sk, c)$
            \end{algorithmic}
            \end{algorithm}
        }{\caption{Decapsulation oracle}}
    \end{floatrow}
\end{figure}


The decapsulation oracle $\mathcal{O}^\decap$ takes a ciphertext $c$ and returns the output of the $\decap$ routine using the secret key. The advantage $\epsilon_\texttt{IND-CCA}$ of an IND-CCA adversary $\mathcal{A}_\texttt{IND-CCA}$ is defined by

\begin{equation*}
    \adv_\texttt{IND-CCA}(A) = \norm{
        P[A^{\mathcal{O}_\decap}(a^\lambda, \pk, c^\ast, K_b) = b] - \frac{1}{2}
    }
\end{equation*}

\subsection{Message authentication code (MAC)}\label{sec:message-authentication-code}
A message authentication code $\mac$ is a collection of routines $(\sign, \verify)$ defined over some key space $\mathcal{K}$, some message space $\mathcal{M}$, and some tag space $\mathcal{T}$. The signing routine $\sign(k, m)$ takes the secret key $k \in \mathcal{K}$ and some message, and outputs a tag $t$. The verification routine $\verify(k, m, t)$ takes the triplet of secret key, message, and tag, and outputs $\texttt{1}$ if the message-tag pair is valid under the secret key, or $\texttt{0}$ otherwise. Many MAC constructions are deterministic. For these constructions it is simpler to denote the signing routine by $t \leftarrow \mac(k, m)$ and perform verification using a simple comparison.

The security of a MAC is defined in an adversarial game in which an adversary, with access to some signing oracle $\mathcal{O}_\sign(m)$, tries to forge a new valid message-tag pair that has never been queried before. The existential unforgeability under chosen message attack (EUF-CMA) game is shown below:

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox[250px]{
            \begin{algorithm}[H]
                \caption{The EUF-CMA game}\label{alg:mac-euf-cma-game}

                \begin{algorithmic}[1]
                    \State $k^\ast \leftsample \mathcal{K}$
                    \State $(\hat{m}, \hat{t}) \leftsample \mathcal{A}^{\mathcal{O}_\sign}()$
                    \State \Return $
                        \llbrack \verify(k^\ast, \hat{m}, \hat{t}) 
                        \land (\hat{m}, \hat{t}) \not\in \mathcal{O}_\sign
                        \rrbrack
                    $
                \end{algorithmic}
            \end{algorithm}
        }{\caption{The \texttt{EUF-CMA} game}}
    \end{floatrow}
\end{figure}

The advantage $\adv_\texttt{EUF-CMA}$ of the existential forgery adversary is the probability that it wins the EUF-CMA game.

We are specifically interested in one-time MAC, whose security goal is identical to EUF-CMA described above, except for the constraint that each secret key can be used to sign exactly one distinct message. This translates to an attack model in which the signing oracle will only answer one signing query. Restricting to one-time usage allows for more efficient MAC constructions. One popular way to build one-time MAC is with universal hash functions (UHF), where each instance is parameterized by a finite field $\mathbb{F}$ and a maximal message length $L \geq 0$. The secret key is a pair of field elements $(k_1, k_2) \in \mathbb{F} \times \mathbb{F}$, and each message is a tuple of up to $L$ field elements $m = (m_1, m_2, \ldots, m_l) \in \mathbb{F}^{\leq L}$. To compute the tag:

\begin{equation*}
    \mac((k_1, k_2), m) = H_\text{xpoly}(k_1, m) + k_2
\end{equation*}

Where the $H_\text{xpoly}$ is a universal hash function:

\begin{equation*}
    H_\text{xpoly}(k_1, (m_1, m_2, \ldots, m_l)) = k_1^l \cdot m_1 + k_1^{l-1} \cdot m_2 + \ldots + k_1 \cdot m_l
\end{equation*}

\begin{lemma}
    For all adversaries (including unbounded ones) against the MAC described above, the probability of winning the one-time EUF-CMA game is at most:

    \begin{equation*}
        \adv_\text{OT-EUF-CMA}(A) \leq \frac{L+1}{\norm{\mathbb{F}}}
    \end{equation*}
\end{lemma}
\begin{proof}
    See \cite{boneh2020graduate} lemma 7.11
\end{proof}

\subsection{Related works}
The Fujisaki-Okamoto transformation \cite{fujisaki1999secure}\cite{hofheinz2017modular} is a family of generic transformations that takes as input a PKE with weaker security, such as OW-CPA, and outputs a PKE or KEM with IND-CCA2 security. The key ingredient in achieving ciphertext non-malleability is with \emph{de-randomization} and \emph{re-encryption}, which first transform a OW-CPA PKE into a \emph{rigid} PKE, then transform the rigid PKE into a KEM. More specifically: \begin{enumerate}
    \item \emph{de-randomization} means that a randomized encryption routine $c \leftsample \encrypt(\pk, m)$ is made into a deterministic encryption routine by deriving randomization coin pseudorandomly: $c \leftarrow \encrypt(\pk, m, r = H(m))$ for some hash function $H$
    \item \emph{re-encryption} means that the transformed decryption routine will run the transformed encryption routine to verify the integrity of the ciphertext. Because after \emph{de-randomization}, each plaintext strictly corresponds exacty one ciphertext, tempering with a ciphertext means that even if the ciphertext decrypts back to the same plaintext, the re-encryption will detect that the ciphertext has been tempered with.
    \item \emph{rigidity} means that the decryption routine is a perfect inverse of the encryption routine: $c = \encrypt(\pk, m) \Leftrightarrow m = \decrypt(\sk, c)$. Converting a one-way secure rigid PKE (which is essentially a trapdoor function) into a IND-CCA2 KEM is well solved problem. We refer readers to \cite{boneh2020graduate} for details on such constructions.
\end{enumerate}

let $\pke = (\keygen_\pke, \encrypt, \decrypt)$ be defined over message space $\mathcal{M}$ and ciphertext space $\mathcal{C}$. Let $G: \mathcal{M} \rightarrow \mathcal{R}$ hash plaintexts into coincs, and let $H: \{0,1\}^\ast \rightarrow \{0,1\}^\ast$ hash byte stream into session keys. Depending on whether the constructed KEM uses implicit or explicit rejection, and the security property of the $\pke$, \cite{hofheinz2017modular} described four variations. They are summarized in table \ref{tbl:fo-variations} and figure \ref{fig:fo-routines}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        name & rejection & PKE security \\
        \hline
        $U^\bot$ & explicit & OW-PCVA \\
        \hline
        $U^{\not\bot}$ & implicit & OW-PCA \\
        \hline
        $U^\bot_m$ & explicit & OW-VA + rigid \\
        \hline
        $U^{\not\bot}_m$ & implicit & OW-CPA + rigid \\
        \hline
    \end{tabular}
    \caption{Variants of modular FO transforms}\label{tbl:fo-variations}
\end{table}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.40\textwidth}
        \begin{algorithm}[H]
            \caption{$\keygen()$}\label{alg:fo-keygen}
            \begin{algorithmic}[1]
                \State $(\pk, \sk^\prime) \leftsample \keygen_\pke()$
                \State $z \leftsample \mathcal{M}$
                \State $\sk \leftarrow (\sk^\prime, z)$
                    \Comment{$U^{\not\bot}, U^{\not\bot}_m$}
                \State $\sk \leftarrow \sk^\prime$
                    \Comment{$U^{\bot}, U^{\bot}_m$}
                \State \Return $(\pk, \sk)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \hspace{0.05\textwidth}
    \begin{minipage}{0.45\textwidth}
        \begin{algorithm}[H]
            \caption{$\encap(\pk)$}\label{alg:fo-encap}
            \begin{algorithmic}[1]
                \State $m \leftsample \mathcal{M}$
                \State $r \leftarrow G(m)$
                \State $c \leftarrow \encrypt(\pk, m, r)$
                \State $K \leftarrow H(m, c)$
                    \Comment{$U^\bot, U^{\not\bot}$}
                \State $K \leftarrow H(m)$
                    \Comment{$U_m^\bot, U_m^{\not\bot}$}
                \State \Return $(c, K)$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \vspace{0.5cm}
    \begin{minipage}{\textwidth}
        \begin{algorithm}[H]
            \caption{$\decap(\sk=(\sk^\prime, z), c)$}\label{alg:fo-decap}
            \begin{algorithmic}[1]
                \State $\hat{m} \leftarrow \decrypt(\sk^\prime, c)$
                \State $\hat{r} \leftarrow G(\hat{m})$
                \State $\hat{c} \leftarrow \encrypt(\pk, \hat{m}, \hat{r})$
                \If{$\hat{c} = c$}
                    \State $K \leftarrow H(\hat{m})$
                        \Comment{$U_m^\bot, U_m^{\not\bot}$}
                    \State $K \leftarrow H(\hat{m}, c)$
                        \Comment{$U^\bot, U^{\not\bot}$}
                \Else
                    \State $K \leftarrow H(z, c)$
                        \Comment{$U^{\not\bot}, U^{\not\bot}_m$}
                    \State $K \leftarrow \bot$
                        \Comment{$U^{\bot}, U^{\bot}_m$}
                \EndIf 
                \State \Return $K$
            \end{algorithmic}
        \end{algorithm}
    \end{minipage}
    \caption{Summary of the modular Fujisaki-Okamoto transformation variations}\label{fig:fo-routines}
\end{figure}

The modular FO transformations enjoy tight security bounds and proven quantum resistance. Variations have been deployed to many post-quantum KEMs submitted to NIST's post-quantum cryptography competition. Kyber, one of the round 3 finalists, uses the $U^{\not\bot}$ transformation. When it was later standardized into FIPS-203, it changed to use the $U^{\not\bot}_m$ transformation for computational efficiencies.

\section{The ``encrypt-then-MAC'' transformation}\label{sec:main-results}
Let $\mathcal{B}^\ast$ denote the set of finite bit strings. Let $\pke(\keygen, \encrypt, \decrypt)$ be a public-key encryption scheme defined over message space $\mathcal{M}$ and ciphertext space $\mathcal{C}$. Let $\mac: \mathcal{K}_\mac \times \mathcal{B}^\ast \rightarrow \mathcal{T}$ be a deterministic message authentication code that takes a key $k \in \mathcal{K}_\mac$, some message $m \in \mathcal{B}^\ast$, and outputs a digest $t \in \mathcal{T}$. Let $G: \mathcal{M} \rightarrow \mathcal{K}_\mac$ be a hash function that maps from $\pke$'s plaintext space to $\mac$'s key space. Let $H: \mathcal{B}^\ast \rightarrow \mathcal{K}_\kem$ be a hash function that maps bit strings into the set of possible shared secrets. The ``encrypt-then-MAC'' transformation $\etm[\pke, \mac, G, H]$ constructs a key encapsulation mechanism $\kem_\etm(\keygen_\kem, \encap, \decap)$, whose routines are described in figure \ref{fig:etm-routines}.

\begin{figure}[H]
    \center
    \begin{algorithm}[H]
        \caption{$\keygen_\etm$}\label{alg:etm-keygen}
        \begin{algorithmic}[1]
            \State $(\pk, \sk^\prime) \leftsample \keygen(1^\lambda)$
            \State $z \leftsample \mathcal{M}$
            \State $\sk \leftarrow (\sk^\prime, z)$
            \State \Return $(\pk, \sk)$
        \end{algorithmic}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{$\encap(\pk)$}\label{alg:etm-encap}
        \begin{algorithmic}[1]
            \State $m \leftsample \mathcal{M}$
            \State $k \leftarrow G(m)$
            \State $c^\prime \leftsample \encrypt(\pk, m)$
            \State $t \leftarrow \mac(k, c^\prime)$
            \State $K \leftarrow H(m, c^\prime)$
            \State $c \leftarrow (c^\prime, t)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{$\decap(\sk, c)$}\label{alg:etm-decap}
        \begin{algorithmic}[1]
            \State $(c^\prime, t) \leftarrow c$
            \State $(\sk^\prime, z) \leftarrow \sk$
            \State $\hat{m} \leftarrow \decrypt(\sk^\prime, c^\prime)$
            \State $\hat{k} \leftarrow G(\hat{m})$
            \If{$\mac(\hat{k}, c^\prime) \neq t$}
                \State $K \leftarrow H(z, c^\prime)$
            \Else
                \State $K \leftarrow H(\hat{m}, c^\prime)$
            \EndIf
            \State \Return $K$
        \end{algorithmic}
    \end{algorithm}
    \caption{$\kem_\etm$ routines}\label{fig:etm-routines} 
\end{figure}

The key generation routine of $\kem_\etm$ is largely identical to that of the $\pke$, only a secret value $z$ is sampled as the implicit rejection symbol. In the encapsulation routine, a MAC key is derived from the randomly sampled plaintext $k \leftarrow G(m)$, then used to sign the unauthenticated ciphertext $c^\prime$. Because the encryption routine might be randomized, the session key is derived from both the message and the ciphertext. Finally, the unauthenticated ciphertext $c^\prime$ and the tag $t$ combine into the authenticated ciphertext $c$ that would be transmitted to the peer. In the decapsulation routine, the decryption $\hat{m}$ of the unauthenticated ciphertext is used to re-derive the MAC key $\hat{k}$, which is then used to re-compute the tag $\hat{t}$. The ciphertext is considered valid if and only if the recomputed tag is identical to the input tag.

For an adversary $A$ to produce a valid tag $t$ for some unauthenticated ciphertext $c^\prime$ under the symmetric key $k \leftarrow G(\decrypt(\sk^\prime, c^\prime))$ implies that $A$ must either know the symmetric key $k$ or produce a forgery. Under the random oracle model, $A$ also cannot know $k$ without knowing its preimage $\decrypt(\sk^\prime, c^\prime)$, so $A$ must either have produced $c^\prime$ honestly, or have broken the one-way security of $\pke$. This means that the decapsulation oracle will not give out information on decryptions that the adversary does not already know. 

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox[300px]{
            \begin{algorithm}[H]
                \caption{$\pco(m, c)$}\label{alg:pco-using-decap-oracle}
                \begin{algorithmic}[1]
                    \State $k \leftarrow G(m)$
                    \State $t \leftarrow \mac(k, c)$
                    \State \Return $\llbrack \mathcal{O}^\decap((c, t)) = H(m, c)\rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }{
            \caption{Every decapsulation oracle can be converted into a plaintext-checking oracle}
            \label{fig:pco-using-decap-oracle}
        }
    \end{floatrow}
\end{figure}

However, a decapsulation oracle can still give out some information: for a known plaintext $m$, all possible encryptions $c^\prime \leftsample \encrypt(\pk, m)$ can be correctly signed, while ciphertexts that don't decrypt back to $m$ cannot be correctly signed. This means that a decapsulation oracle can be converted into a plaintext-checking oracle (algorithm \ref{alg:pco-using-decap-oracle}), so every chosen-ciphertext attack against the KEM can be converted into a plaintext-checking attack against the underlying PKE.

On the other hand, if the underlying PKE is one-way secure against plaintext-checking attack that makes $q$ plaintext-checking queries, then ``encrypt-then-MAC'' KEM is semantically secure under chosen ciphertext attacks making the same number of decapsulation queries:

\begin{theorem}\label{thm:ow-pca-implies-kem-ind-cca2}
    For every \texttt{IND-CCA2} adversary $A$ against $\kem_\etm$ that makes $q$ decapsulation queries, there exists an \texttt{OW-PCA} adversary $B$ who makes at least $q$ plaintext-checking queries against the underlying $\pke$, and an one-time existential forgery adversary $C$ against the underlying $\mac$ such that

    \begin{equation*}
        \texttt{Adv}_\texttt{IND-CCA2}(A) \leq q \cdot \adv_\texttt{OT-MAC}(C) + 2 \cdot \texttt{Adv}_\texttt{OW-PCA}(B)
    \end{equation*}
\end{theorem}

Theorem \ref{thm:ow-pca-implies-kem-ind-cca2} naturally flows into an equivalence relationship between the security of the KEM and the security of the PKE:

\begin{lemma}
    $\kem_\etm$ is IND-CCA2 secure if and only if the input $\pke$ is OW-PCA secure
\end{lemma}

\subsection{Proof of theorem \ref{thm:ow-pca-implies-kem-ind-cca2}}
\begin{proof}
    We will prove theorem \ref{thm:ow-pca-implies-kem-ind-cca2} using a sequence of games.

    \begin{figure}[H]
        \begin{floatrow}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{IND-CCA2 game for KEM}\label{alg:game-0}
                    \begin{algorithmic}[1]
                        \State $(\pk, \sk) \leftsample \keygen_\etm()$
                        \State $m^\ast \leftsample \mathcal{M}$
                        \State $c^\prime \leftsample \encrypt(\pk, m^\ast)$
                        \State $k^\ast \leftarrow G(m^\ast)$
                        \State $t \leftarrow \mac(k, c^\prime)$
                        \State $c^\ast \leftarrow (c^\prime, t)$
                        \State $K_0 \leftarrow H(m^\ast, c^\prime)$
                        \State $K_1 \leftsample \mathcal{K}_\kem$
                        \State $b \leftsample \{0,1\}$
                        \State $\hat{b} \leftarrow A^{\mathcal{O}^\decap}(\pk, c^\ast, K_b)$
                        \State \Return $\llbrack \hat{b} = b \rrbrack$
                    \end{algorithmic}
                \end{algorithm}
            }{}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^\decap(c)$}\label{alg:true-decap-oracle}
                    \begin{algorithmic}[1]
                        \State $(c^\prime, t) \leftarrow c$
                        \State $\hat{m} = \decrypt(\sk^\prime, c^\prime)$
                        \State $\hat{k} \leftarrow G(\hat{m})$
                        \If{$\mac(\hat{k}, c^\prime) = t$}
                            \State $K \leftarrow H(\hat{m}, c^\prime)$
                        \Else 
                            \State $K \leftarrow H(z, c^\prime)$
                        \EndIf 
                        \State \Return $K$
                    \end{algorithmic}
                \end{algorithm}
            }{}
        \end{floatrow}
        \begin{floatrow}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^G(m)$}\label{alg:hash-oracle-g}
                    \begin{algorithmic}[1]
                        \If{$\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G : \tilde{m} = m$}
                            \State \Return $\tilde{k}$
                        \EndIf
                        \State $k \leftsample \mathcal{K}_\mac$
                        \State $\mathcal{L}^G \leftarrow \mathcal{L}^G \cup \{(m, k)\}$
                        \State \Return $k$
                    \end{algorithmic}
                \end{algorithm}
            }{}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^H(m, c)$}\label{alg:hash-oracle-h}
                    \begin{algorithmic}[1]
                        \If{$\exists (\tilde{m}, \tilde{c}, \tilde{K}) \in \mathcal{L}^H : \tilde{m} = m \land \tilde{c} = c$}
                            \State \Return $\tilde{K}$
                        \EndIf
                        \State $K \leftsample \mathcal{K}_\kem$
                        \State $\mathcal{L}^H \leftarrow \mathcal{L}^H \cup \{(m, c, K)\}$
                        \State \Return $K$
                    \end{algorithmic}
                \end{algorithm}
            }{}
        \end{floatrow}
    \end{figure}

    \emph{Game 0} is the standard IND-CCA2 game for KEMs. The decapsulation oracle $\mathcal{O}^\decap$ executes the decapsulation routine using the challenge keypair and return the results faithfully. The queries made to the hash oracles $\mathcal{O}^G, \mathcal{O}^H$ are recorded to their respective tapes $\mathcal{L}^G, \mathcal{L}^H$.

    \begin{figure}[H]
        \begin{floatrow}
            \ffigbox[270px]{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^\decap_1(c)$}\label{alg:sim-decap-oracle}
                    \begin{algorithmic}[1]
                        \State $(c^\prime, t) \leftarrow c$
                        \If{$\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G : 
                            \tilde{m} = \decrypt(\sk^\prime, c^\prime)
                            \land \mac(\tilde{k}, c^\prime) = t
                        $}
                            \State $K \leftarrow H(\tilde{m}, c^\prime)$
                        \Else
                            \State $K \leftarrow H(z, c^\prime)$
                        \EndIf
                        \State \Return $K$
                    \end{algorithmic}
                \end{algorithm}
            }{
                \caption{Simulated decapsulation oracle}
            }
        \end{floatrow}
    \end{figure}

    \emph{Game 1} is identical to game 0 except that the true decapsulation oracle $\mathcal{O}^\decap$ is replaced with a simulated oracle $\mathcal{O}^\decap_1$. Instead of directly decrypting $c^\prime$ as in the decapsulation routine, the simulated oracle searches through the tape $\mathcal{L}^G$ to find a matching query $(\tilde{m}, \tilde{k})$ such that $\tilde{m}$ is the decryption of $c^\prime$. The simulated oracle then uses $\tilde{k}$ to validate the tag $t$ against $c^\prime$.

    If the simulated oracle accepts the queried ciphertext as valid, then there is a matching query that also validates the tag, which means that the queried ciphertext is honestly generated. Therefore, the true oracle must also accept the queried ciphertext. On the other hand, if the true oracle rejects the queried ciphertext (and output the implicit rejection $H(z, c^\prime)$), then the tag is simply invalid under the MAC key $k = G(\decrypt(\sk^\prime, c^\prime))$. Therefore, there could not have been a matching query that also validates the tag, and the simulated oracle must also rejects the queried ciphertext.

    This means that from the adversary $A$'s perspective, game 1 and game 0 differ only when the true oracle accepts while the simulated oracle rejects, which means that $t$ is a valid tag for $c^\prime$ under $k = G(\decrypt(\sk^\prime, c^\prime))$, but $k$ has never been queried. Under the random oracle model, such $k$ is a uniformly random sample of $\mathcal{K}_\mac$ that the adversary does not know, so for $A$ to produce a valid tag is to produce a forgery against the $\mac$ under an unknown and uniformly random key. Furthermore, the security game does not include a signing oracle, so this is a zero-time forgery. While zero-time forgery is not a standard security definition for a MAC, we can bound it by the advantage of a one-time forgery adversary $C$:

    \begin{equation*}
        P\left[\mathcal{O}^\decap(c) \neq \mathcal{O}^\decap_1(c)\right]
        \leq \adv_\texttt{OT-MAC}(C)
    \end{equation*}

    Across all $q$ decapsulation queries, the probability that at least one query is a forgery is thus at most $q \cdot P\left[\mathcal{O}^\decap(c) \neq \mathcal{O}^\decap_1(c)\right]$. By the difference lemma:

    \begin{equation*}
        \adv_{G_0}(A) - \adv_{G_1}(A) \leq q\cdot  \adv_\texttt{OT-MAC}(C)
    \end{equation*}

    \emph{Game 2} is identical to game 1, except that on line 4 of algorithm \ref{alg:game-0}, the challenger samples a uniformly random MAC key $k^\ast \leftsample \mathcal{K}_\mac$ instead of deriving it from $m$. From $A$'s perspective the two games are indistinguishable, unless $A$ queries $G$ with the value of $m^\ast$. Denote the probability that $A$ queries $G$ with $m^\ast$ by $P[\texttt{QUERY G}]$, then:

    \begin{equation*}
        \adv_{G_1}(A) - \adv_{G_2}(A) \leq P\left[\texttt{QUERY G}\right]
    \end{equation*}

    \emph{Game 3} is identical to game 2, except that on line 7 of algorithm \ref{alg:game-0}, the challenger samples a uniformly random shared secret $K_0 \leftsample \mathcal{K}_\kem$ instead of deriving it from $m^\ast$ and $c^\prime$. From $A$'s perspective the two games are indistinguishable, unless $A$ queries $H$ with $(m^\ast, \cdot)$. Denote the probability that $A$ queries $H$ with $(m^\ast, \cdot)$ by $P[\texttt{QUERY H}]$, then:

    \begin{equation*}
        \adv_{G_2}(A) - \adv_{G_3}(A) \leq P\left[\texttt{QUERY H}\right]
    \end{equation*}

    Since in game 3, both $K_0$ and $K_1$ are uniformly random and independent of all other variables, no adversary can have any advantage: $\adv_{G_3}(A) = 0$.

    \begin{figure}[H]
        \begin{floatrow}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$B(\pk, {c^\prime}^\ast)$}\label{alg:ow-pca-adversary}
                    \begin{algorithmic}[1]
                        \State $z \leftsample \mathcal{M}$
                        \State $k \leftsample \mathcal{K}_\mac$
                        \State $t \leftarrow \mac(k, {c^\prime}^\ast)$
                        \State $c^\ast \leftarrow ({c^\prime}^\ast, t)$
                        \State $K \leftsample \mathcal{K}_\kem$
                        \State $\hat{b} \leftarrow A^{
                            \mathcal{O}^\decap_B, \mathcal{O}^G_B, \mathcal{O}^H_B
                        }(\pk, c^\ast, K)$
                        \If{$\texttt{ABORT}(m)$}
                            \State \Return $m$
                        \EndIf
                    \end{algorithmic}
                \end{algorithm}
            }{}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^\decap_B(c)$}\label{alg:sim-decap-oracle-b}
                    \begin{algorithmic}[1]
                        \State $(c^\prime, t) \leftarrow c$
                        \If{$\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G : 
                            % \tilde{m} = \decrypt(\sk^\prime, c^\prime)
                            \pco(c^\prime, \tilde{m}) = 1
                            \land \mac(\tilde{k}, c^\prime) = t
                        $}
                            \State $K \leftarrow H(\tilde{m}, c^\prime)$
                        \Else
                            \State $K \leftarrow H(z, c^\prime)$
                        \EndIf
                        \State \Return $K$
                    \end{algorithmic}
                \end{algorithm}
            }{}
        \end{floatrow}
        \begin{floatrow}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^G_B(m)$}\label{alg:hash-oracle-g-b}
                    \begin{algorithmic}[1]
                        \If{$\pco(m, {c^\prime}^\ast) = 1$}
                            \State $\texttt{ABORT}(m)$
                        \EndIf
                        \If{$\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G : \tilde{m} = m$}
                            \State \Return $\tilde{k}$
                        \EndIf
                        \State $k \leftsample \mathcal{K}_\mac$
                        \State $\mathcal{L}^G \leftarrow \mathcal{L}^G \cup \{(m, k)\}$
                        \State \Return $k$
                    \end{algorithmic}
                \end{algorithm}
            }{}
            \ffigbox{
                \begin{algorithm}[H]
                    \caption{$\mathcal{O}^H_B(m, c)$}\label{alg:hash-oracle-h-b}
                    \begin{algorithmic}
                        \If{$\pco(m, {c^\prime}^\ast) = 1$}
                            \State $\texttt{ABORT}(m)$
                        \EndIf
                        \If{$
                            \exists (\tilde{m}, \tilde{c}, \tilde{K}) \in \mathcal{L}^H 
                            : \tilde{m} = m \land \tilde{c} = c
                        $}
                            \State \Return $\tilde{K}$
                        \EndIf
                        \State $K \leftsample \mathcal{K}_\kem$
                        \State $\mathcal{L}^H \leftarrow \mathcal{L}^H \cup \{(m, c, K)\}$
                        \State \Return $K$
                    \end{algorithmic}
                \end{algorithm}
            }{}
        \end{floatrow}
    \end{figure}
    We will bound $P[\texttt{QUERY G}]$ and $P[\texttt{QUERY H}]$ by constructing a OW-PCA adversary $B$ against the underlying PKE that uses $A$ as a sub-routine. $B$'s behaviors are described in algorithms \ref{alg:ow-pca-adversary}, \ref{alg:sim-decap-oracle-b}, \ref{alg:hash-oracle-g-b}, and \ref{alg:hash-oracle-h-b}.

    $B$ simulates game 3 for $A$: receiving the public key $\pk$ and challenge encryption ${c^\prime}^\ast$, $B$ samples random MAC key and session key to produce the challenge encapsulation, then feeds it to $A$. When simulating the decapsulation oracle, $B$ uses the plaintext-checking oracle to look for matching queries in $\mathcal{L}^G$. When simulating the hash oracles, $B$ uses the plaintext-checking oracle to detect when $m^\ast = \decrypt(\sk^\prime, {c^\prime}^\star)$ has been queried. When $m^\ast$ is queried, $B$ terminates $A$ and returns $m^\ast$ to win the OW-PCA game. In other words:

    \begin{equation*}
        \begin{aligned}
            P\left[\texttt{QUERY G}\right] &\leq \adv_\texttt{OW-PCA}(B) \\
            P\left[\texttt{QUERY H}\right] &\leq \adv_\texttt{OW-PCA}(B) \\
        \end{aligned}
    \end{equation*}

    Combining all equations above produce the desired security bound.
\end{proof}

\section{Application to Kyber}\label{sec:experimental-results}
CRYSTALS-Kyber \cite{bos2018crystals}\cite{avanzi2019crystals} is an IND-CCA2 secure key encapsulation mechanism whose security is based on the conjecture hardness of the decisional Module Learning with Error problem. To achieve the the IND-CCA2 security, Kyber first constructs an IND-CPA secure public key encryption scheme based on \cite{lpr2013ideal}, then apply a slightly modified variation of the Fujisaki-Okamoto transformation described in \cite{hofheinz2017modular}. The resulting decapsulation routine is especially inefficient because Kyber's IND-CPA encryption routine incurs significantly more computational cost than the decryption routine. This makes Kyber a prime target for demonstrating the performance improvements enjoyed by the ``encrypt-then-MAC'' KEM construction.

We took the IND-CPA PKE routines (algorithms 4, 5, 6 in \cite{avanzi2019crystals}) and applied the ``encrypt-then-MAC'' transformation. The resulting KEM routines are described in algorithms \ref{alg:kyber-ae-keygen}, \ref{alg:kyber-ae-encap}, and \ref{alg:kyber-ae-decap}.

\begin{algorithm}[H]
    \caption{\texttt{Kyber.CCAKEM.KeyGen()}}\label{alg:kyber-ae-keygen}
    \begin{algorithmic}[1]
        \State $z \leftsample \{0,1\}^{256}$
        \State $(\pk, \sk^\prime) \leftsample \texttt{Kyber.CPAPKE.KeyGen()}$
        \State $\sk = (\sk^\prime, \pk, H(\pk), z)$
            \Comment{H is instantiated with SHA3-256}
        \State \Return $(\pk, \sk)$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{\texttt{Kyber.CCAKEM.Encap$^+$(\pk)}}\label{alg:kyber-ae-encap}
    \begin{algorithmic}[1]
        \State $m \leftsample \{0,1\}^{256}$
        \State $m'= H(m)$
            \Comment{Do not output system RNG directly}
        \State $(\bar{K}, k) = G(m' \Vert H(\pk))$
            \Comment{G is instantiated with SHA3-512}
        \State $r \leftsample \mathcal{R}$
        \State $c^\prime  \leftarrow \texttt{Kyber.CPAPKE.Enc}(\pk, m', r)$
            \State $t=\mac(k, c^\prime)$
        \State $K = \texttt{KDF}(\bar{K} \Vert t)$
            \Comment{\texttt{KDF} is instantiated with Shake256}
        \State $c \leftarrow (c^\prime, t)$
        \State \Return $(c, K)$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{$\texttt{Kyber.CCAKEM.Decap}^+ (\sk, c)$}\label{alg:kyber-ae-decap}
    \begin{algorithmic}[1]
        \Require Secret key $\sk = (\sk^\prime, \pk, H(\pk), z)$
        \Require Ciphertext $c = (c^\prime, t)$
        \State $(\sk^\prime, \pk, h, z) \leftarrow \sk$
        \State $(c^\prime, t) \leftarrow c$
        \State $\hat{m} = \texttt{Kyber.CPAPKE.Dec}(\sk^\prime, c^\prime)$ 
        \State $(\overline{K}, k) =   G(m^\prime \Vert h)$
        \State $\hat{t}=\mac(k, c)$
        \If{$\hat{t} = t$}
            \State $K  = \texttt{KDF}(\bar{K} \Vert t)$ 
         \Else 
            \State $K  = \texttt{KDF}(z \Vert t)$ 
        \EndIf
            \State \Return $K$
    \end{algorithmic}
\end{algorithm}

\begin{remark}
    We derive the MAC key from both the plaintext $m$ and the public key $\pk$ for the same reason \cite{avanzi2019crystals} derives the pseudorandom coin from both $m$ and $\pk$. One is to allow both parties to participate in the encryption process, the other is to prevent a quantum adversary from pre-computing a large table of MAC keys that can then be brute-forced.
\end{remark}
\begin{remark}
    We chose to derive the shared secret $K$ from the ciphertext digest $t$ instead of the ciphertext itself, which saves a few Keccak permutations since $t$ is only 128 bits while the full ciphertext could span more than a thousand bytes. This should not impact the security of the scheme since finding collision for an unknown MAC key constitutes a forgery attack on the MAC.
\end{remark}
\begin{remark}
    We constructed the ``encrypt-then-MAC'' transformation to use implicit rejection so that we can directly use existing implementation of Kyber with minimal modification. In principle, a construction with explicit rejection should also be equally secure and efficient.
\end{remark}
\begin{remark}
    We chose to use MAC with 256-bit key size and 128-bit tag size. When modeling the security threats, we assumed that the adversary may have access to quantum computers, making it necessary to use the maximal key size of common MACs while maintaining the minimum 128-bit security. On the other hand, the tag size can be relative small because the decapsulator (aka the decapsulation oracle) is assumed to be a classical computer, so there is no quantum speedup on brute-forcing a valid tag.
\end{remark}

When instantiating an instance of $\kem(\keygen, \encap, \decap)$, there are a variety of MAC's to chose from. We experimented with Poly1305, AES-256-GCM (aka GMAC), AES-256-CBC (aka CMAC), and KMAC-256. We instantiated an intance of the ``encrypt-then-MAC'' KEM using each of the chosen MAC, then measured the median number of CPU cycles needed to perform the key generation, encapsulation, and decapsulation routines among 10000 runs. The Kyber implementation is taken from the reference implementation (https://github.com/pq-crystals/kyber). MAC implementations are taken from OpenSSL 3.3.1. The source code is compiled with GCC 11.4.1 on Amazon Linux 2. Performance measurements were taken from a c7a.medium AWS EC2 instance with a AMD EPYC 9R14 (1) @ 3.700GHz. The experimental results are listed in table \ref{tbl:kyber-ae-perf}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Name & Security level & $\keygen$ & $\encap$ & $\decap$ \\
        \hline
        Kyber512 & 128 bits & 75945 & 91467& 121185 \\
        \hline
        Kyber512 + Poly1305& 128 bits & 76907 & 93157 & 33733 \\
        \hline
        Kyber512 + GMAC& 128 bits & 76917 & 95419 & 37725 \\
        \hline
        Kyber512 + CMAC& 128 bits & 76907 & 99839 & 40117 \\
        \hline
        Kyber512 + KMAC-256& 128 bits & 76387 & 101009 & 40741 \\
        \hline
        Kyber768 & 192 bits & 129895 & 146405& 186445 \\
        \hline
        Kyber768 + Poly1305& 192 bits & 128205 & 146405& 43315 \\
        \hline
        Kyber768 + GMAC& 192 bits & 127997 & 149525 & 46513 \\
        \hline
        Kyber768 + CMAC& 192 bits & 129167 & 151007 & 49841 \\
        \hline
        Kyber768 + KMAC-256& 192 bits & 128829 & 155219 & 52415 \\
        \hline
        Kyber1024 & 256 bits & 194921 & 199185 & 246245 \\
        \hline
        Kyber1024 + Poly1305& 256 bits & 196013 & 205763 & 51375 \\
        \hline
        Kyber1024 + GMAC& 256 bits & 196039 & 208805 & 54573 \\
        \hline
        Kyber1024 + CMAC& 256 bits & 195389 & 213667 & 59175 \\
        \hline
        Kyber1024 + KMAC-256& 256 bits & 196117 & 216761 & 62269 \\
        \hline
    \end{tabular}
    \caption{Performance measurements}\label{tbl:kyber-ae-perf}
\end{table}

Compared to Kyber using the FO transform, our proposed construction adds a small amount of runtime overhead (for computing a digest) in the encapsulation routine and a small increase in ciphertext size (for the 128-bit tag). In exchange, we see significant performance runtime savings in the decapsulation routines. This trade-off is especially meaningful in a key exchange protocol where one party has substantially more computationl resource than the other. For example, in many experimental implementation of TLS with post-quantum KEMs (such as \href{https://blog.cloudflare.com/the-tls-post-quantum-experiment/}{CECPQ2}), the client (might be IoT devices) runs $\keygen$ and $\decap$ while the server (usually data centers) runs $\encap$.

\section{Conclusions and future works}\label{sec:future-works}
We applied the ``encrypt-then-MAC'' transformation to Kyber and saw meaningful performance improvements over using de-randomization and re-encryption. Unfortunately the resulting KEM does not achieve the desired full IND-CCA2 security, because Kyber is known to be vulnerable to key-recovery plaintext-checking attack (KR-PCA) \cite{ravi2019generic}\cite{ueno2022curse}. We speculate that while Kyber with ``encrypt-then-MAC'' could not achieve the full IND-CCA2 security, it can still be safe for use in ephemeral key exchange, where each secret key is used to decrypt at most one ciphertext (the KR-PCA requires a few hundred decryption queries to recover the secret key).

In section \ref{sec:main-results}, we showed that if the input PKE is OW-PCA secure, then the resulting KEM is IND-CCA2 secure. One sufficient condition for OW-PCA security is one-way security plus rigidity. If the input PKE is rigid, then $m = \decrypt(\sk, c)$ is equivalent to $c = \encrypt(\pk, m)$, so a plaintext-checking oracle can be simulated without any secret information. However, the $U_m^{\not\bot}$ transformation in \cite{hofheinz2017modular} can already transform an OW-CPA secure and rigid PKE into an IND-CCA2 secure KEM with minimal overhead: the encapsulation and decapsulation routines each adds a hash of the plaintext to the encryption and decryption routine. In other words, where the input PKE is rigid, ``encrypt-then-MAC'' doesn't offer any performance advantage. It remains an open problem whether there exists a PKE that is OW-PCA secure but not rigid. If such a PKE exists, then ``encrypt-then-MAC'' would be a preferable strategy for constructing an IND-CCA2 KEM.



%%%% 8. BILBIOGRAPHY %%%%
\bibliographystyle{alpha}
\bibliography{abbrev3,crypto,biblio}
% - Download abbrev3.bib and crypto.bib from https://cryptobib.di.ens.fr/
% - Use bilbio.bib for additional references not in the cryptobib database.
%   If possible, take them from DBLP.

\end{document}
