%%%% 1. DOCUMENTCLASS %%%%
% \documentclass[journal=tches,submission,notanonymous]{iacrtrans}
\documentclass[floatrow,journal=tches,submission]{iacrtrans}
%%%% NOTES:
% - Change "journal=tosc" to "journal=tches" if needed
% - Change "submission" to "final" for final version
% - Add "notanonymous" to reveal authors
% - Add "spthm" for LNCS-like theorems


%%%% 2. PACKAGES %%%%
\usepackage{algorithm}
\usepackage{algpseudocode}
% \usepackage[demo]{graphicx}

%%%% 3. AUTHOR, INSTITUTE %%%%
\author{
    Ganyu Xu\inst{1}
    \and Guang Gong\inst{1}
    \and Kalikinkar Mandal\inst{2}
}
\institute{
  University of Waterloo, Waterloo, Canada, \email{{g66xu,ggong}@uwaterloo.ca}
  \and
  University of New Brunswick, New Brunswick, Canada, \email{kmandal@unb.ca}
}
%%%% NOTES:
% - We need a city name for indexation purpose, even if it is redundant
%   (eg: University of Atlantis, Atlantis, Atlantis)
% - \inst{} can be omitted if there is a single institute,
%   or exactly one institute per author

% Custom commands
\newcommand{\pke}{\texttt{PKE}}
\newcommand{\keygen}{\texttt{KeyGen}}
\newcommand{\encrypt}{\texttt{Enc}}
\newcommand{\decrypt}{\texttt{Dec}}
\newcommand{\kem}{\texttt{KEM}}
\newcommand{\encap}{\texttt{Encap}}
\newcommand{\decap}{\texttt{Decap}}
\newcommand{\etm}{\texttt{EtM}}  % encrypt-then-mac
\newcommand{\mac}{\texttt{MAC}}
\newcommand{\sign}{\texttt{Sign}}
\newcommand{\verify}{\texttt{Verify}}
\newcommand{\pk}{\texttt{pk}}
\newcommand{\sk}{\texttt{sk}}
\newcommand{\pco}{\texttt{PCO}}
\newcommand{\cvo}{\texttt{CVO}}
\newcommand{\leftsample}{\stackrel{\$}{\leftarrow}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newcommand{\norm}[1]{\left\lvert #1 \right\rvert}
\newcommand{\adv}{\texttt{Adv}}
\newcommand{\fotplus}{\texttt{FOT+}}

%%%% 4. TITLE %%%%
\title[IND-CCA2 secure KEM using encrypt-then-MAC]{
Fast Fujisaki-Okamoto transformation  using encrypt-then-mac and applications to Kyber}
%%%% NOTES:
% - If the title is too long, or includes special macro, please
%   provide a "running title" as optional argument: \title[Short]{Long}
% - You can provide an optional subtitle with \subtitle.

\begin{document}

\maketitle


%%%% 5. KEYWORDS %%%%
\keywords{
    Key encapsulation mechanism, 
    post-quantum cryptography,
    lattice cryptography,
    Fujisaki-Okamoto transformation
}


%%%% 6. ABSTRACT %%%%
\begin{abstract}
  The modular Fujisaki-Okamoto (FO) transformation takes public-key encryption with weaker security and constructs a key encapsulation mechanism (KEM) with indistinguishability under adaptive chosen ciphertext attacks. While the modular FO transform enjoys tight security bound and quantum resistance, it also suffers from computational inefficiency and vulnerabilities to side-channel attacks due to using de-randomization and re-encryption for providing ciphertext integrity. In this work, we propose an alternative KEM construction that achieves ciphertext integrity using a message authentication code (MAC) and instantiate a concrete instance using ML-KEM. Our experimental results showed that where the encryption routine incurs heavy computational cost, replacing re-encryption with MAC provides substantial performance improvements at comparable security level.
\end{abstract}


%%%% 7. PAPER CONTENT %%%%
\section{Introduction}
The Fujisaki-Okamoto transformation \cite{fujisaki1999secure} is a generic construction that takes cryptographic primitives of lesser security and constructs a public-key encryption scheme with indistinguishability under adaptive chosen ciphertext attacks. Later works \cite{hofheinz2017modular} extended the original transformation to the construction of key encapsulation mechanism, which has been adopted by many post-quantum schemes such as Kyber \cite{bos2018crystals}, FrodoKEM \cite{bos2016frodo}, and SABER \cite{d2018saber}.

The current state of the FO transformation enjoys tight security bound and quantum resistance \cite{hofheinz2017modular}, but also leaves many deficiencies to be improved on. One such shortcoming is the use of re-encryption for providing ciphertext integrity \cite{bernstein2018towards}, which requires the decapsulation routine to run the encryption routine as a subroutine. In many post-quantum schemes, such as Kyber, the encryption routine is substantially more expensive than the decryption routine, so running the encryption routine in the decapsulation routine inflates the computational cost of the decapsulator. In addition, running the encryption as a subroutine introduces risks of side-channel vulnerabilities that may expose the plaintext or the secret key \cite{ravi2019generic}\cite{ueno2022curse}.

The problem of ciphertext integrity was solved in symmetric cryptography: given a semantically secure symmetric cipher and an existentially unforgeable message authentication code, combining them using ``encrypt-then-mac'' provides authenticated encryption \cite{bellare2000authenticated}. We took inspiration from this strategy and applied a similar technique to transform an IND-CPA secure public-key encryption scheme into an IND-CCA2 secure key encapsulation mechanism. Using a message authentication code for ciphertext integrity replaces the re-encryption step in decryption with the computation of an authenticator, which offers significant performance improvements while maintaining comparable level of security.

The main challenge in applying ``encrypt-then-mac'' to public-key cryptography is the lack of a pre-shared symmetric key. We proposed to derive the symmetric key by hashing the plaintext message. In section \ref{sec:main-results}, we prove that under the random oracle model, if the input public-key encryption scheme is one-way secure against plaintext-checking attack and the input message authentication code is one-time existentially unforgeable, then the transformed key encapsulation mechanism is IND-CCA2 secure.

In section \ref{sec:experimental-results}, we instantiate concrete instances of our constructions by combining Kyber with GMAC and Poly1305. Our experimental results showed that replacing re-encryption with computing authenticator leads to significant performance improvements in the decapsulation routine while incurring only minimal overhead in the encapsulation routine.

\section{Preliminaries and previous results}

\subsection{Public-key encryption scheme}
A public key encryption scheme $\pke$ is a collection of three routines $(\keygen, \encrypt, \decrypt)$ defined over some message space $\mathcal{M}$ and some ciphertext space $\mathcal{C}$. Where the encryption routine is probabilistic, the source of randomness is denoted by the coin space $\mathcal{R}$.

The encryption routine $\encrypt(\pk, m)$ takes a public key, a plaintext message, and outputs a ciphertext $c \in \mathcal{C}$. Where the encryption routine is probabilistic, specifying a pseudorandom seed $r \in \mathcal{R}$ will make the encryption routine behave deterministically. The decryption routine $\decrypt(\sk, c)$ takes a secret key, a ciphertext, and outputs the decryption $\hat{m}$ if the ciphertext is valid under the given secret key, or the rejection symbol $\bot$ if the ciphertext is invalid.

We discuss the security of a $\pke$ using the sequence of games described in \cite{shoup2004sequences}. Specifically, we first define the $\texttt{OW-ATK}$ as they pertain to a public key encryption scheme. In later section we will define the $\texttt{IND-CCA}$ game as it pertains to a key encapsulation mechanism.

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{
                    The $\texttt{OW-ATK}$ game
                }\label{alg:pke-ow-atk-game}
                \begin{algorithmic}[1]
                    \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                    \State $m^\ast \leftsample \mathcal{M}$
                    \State $c^\ast \leftsample \encrypt(\pk, m^\ast)$
                    \State $\hat{m} \leftsample \mathcal{A}^{\mathcal{O}_\texttt{ATK}}(1^\lambda, \pk, c^\ast)$
                    \State \Return $\llbrack m^\ast = \hat{m} \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }
        {\caption{The \texttt{OW-ATK} game}}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{$\pco(m \in \mathcal{M}, c \in \mathcal{C})$}\label{alg:pco}
                \begin{algorithmic}[1]
                    \State \Return $\llbrack \decrypt(\sk, c) = m \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }
        {\caption{Plaintext-checking oracle}}
    \end{floatrow}
    \label{fig:pco-and-cvo}
\end{figure}

In the \texttt{OW-ATK} game (see figure \ref{alg:pke-ow-atk-game}), an adversary's goal is to recover the decryption of a randomly generated ciphertext. A challenger randomly samples a keypair and a challenge plaintext $m^\ast$, encrypts the challenge plaintext $c^\ast \leftsample \encrypt(\pk, m^\ast)$, then gives $\pk$ and $c^\ast$ to the adversary $A$. The adversary $A$, with access to some oracle $\mathcal{O}_\texttt{ATK}$, outputs a guess decryption $\hat{m}$. $A$ wins the game if its guess $\hat{m}$ is equal to the challenge plaintext $m^\ast$. The \textit{advantage} $\adv_\texttt{OW-ATK}$ of an adversary in this game is the probability that it wins the game:

\begin{equation*}
    \adv_\texttt{OW-ATK}(A) = P\left[
        A(\pk, c^\ast) = m^\ast \vert
        (\pk, \sk) \leftsample \keygen() ;
        m^\ast \leftsample \mathcal{M};
        c^\ast \leftsample \encrypt(\pk, m^\ast)
    \right]
\end{equation*}

The capabilities of the oracle $\mathcal{O}_\texttt{ATK}$ depends on the choice of security goal $\texttt{ATK}$. Particularly relevant to our result is security against plaintext-checking attack (PCA), for which the adversary has access to a plaintext-checking oracle (PCO) (see figure \ref{alg:pco}). A PCO takes as input a plaintext-ciphertext pair $(m, c)$ and returns \texttt{True} if $m$ is the decryption of $c$ or \texttt{False} otherwise.

\subsection{Key encapsulation mechanism (KEM)}
A key encapsulation mechanism is a collection of three routines $(\keygen, \encap, \decap)$ defined over some ciphertext space $\mathcal{C}$ and some key space $\mathcal{K}$. The key generation routine takes the security parameter $1^\lambda$ and outputs a keypair $(\pk, \sk) \leftsample \keygen(1^\lambda)$. $\encap(\pk)$ is a probabilistic routine that takes a public key $\pk$ and outputs a pair of values $(c, K)$ where $c \in \mathcal{C}$ is the ciphertext (also called encapsulation) and $K \in \mathcal{K}$ is the shared secret (also called session key). $\decap(\sk, c)$ is a deterministic routine that takes the secret key $\sk$ and the encapsulation $c$ and returns the shared secret $K$ if the ciphertext is valid. Some KEM constructions use explicit rejection, where if $c$ is invalid then $\decap$ will return a rejection symbol $\bot$; other KEM constructions use implicit rejection, where if $c$ is invalid then $\decap$ will return a ``fake'' session key that depends on the ciphertext and some other secret values.

The IND-CCA security of a KEM is defined by an adversarial game in which an adversary's goal is to distinguish pseudorandom shared secret (generated by running the $\encap$ routine) and a truly random value.

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox{
            \begin{algorithm}[H]
                \caption{
                    \texttt{IND-CCA} game for \kem
                }\label{alg:kem-ind-cca-game}
                
                \begin{algorithmic}[1]
                    \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                    \State $(c^\ast, K_0) \leftsample \encap(\pk)$
                    \State $K_1 \leftsample \mathcal{K}$
                    \State $b \leftsample \{0, 1\}$
                    \State $\hat{b} \leftsample A^{\mathcal{O}_\decap}(
                        1^\lambda, \pk, c^\ast, K_b
                    )$
                    \State \Return $\llbrack \hat{b} = b \rrbrack$
                \end{algorithmic}
            \end{algorithm}
        }{\caption{The \texttt{KEM-IND-CCA2} game}}
        \ffigbox{
            \begin{algorithm}[H]
            \caption{
                $\mathcal{O}_\decap(c)$
            }
            \begin{algorithmic}[1]
                \State \Return $\decap(\sk, c)$
            \end{algorithmic}
            \end{algorithm}
        }{\caption{Decapsulation oracle}}
    \end{floatrow}
\end{figure}


The decapsulation oracle $\mathcal{O}^\decap$ takes a ciphertext $c$ and returns the output of the $\decap$ routine using the secret key. The advantage $\epsilon_\texttt{IND-CCA}$ of an IND-CCA adversary $\mathcal{A}_\texttt{IND-CCA}$ is defined by

\begin{equation*}
    \adv_\texttt{IND-CCA}(A) = \norm{
        P[A^{\mathcal{O}_\decap}(a^\lambda, \pk, c^\ast, K_b) = b] - \frac{1}{2}
    }
\end{equation*}

\subsection{Message authentication code (MAC)}
A message authentication code $\mac$ is a collection of routines $(\sign, \verify)$ defined over some key space $\mathcal{K}$, some message space $\mathcal{M}$, and some tag space $\mathcal{T}$. The signing routine $\sign(k, m)$ takes the secret key $k \in \mathcal{K}$ and some message, and outputs a tag $t$. The verification routine $\verify(k, m, t)$ takes the triplet of secret key, message, and tag, and outputs $\texttt{1}$ if the message-tag pair is valid under the secret key, or $\texttt{0}$ otherwise. Many MAC constructions are deterministic. For these constructions it is simpler to denote the signing routine by $t \leftarrow \mac(k, m)$ and perform verification using a simple comparison.

The security of a MAC is defined in an adversarial game in which an adversary, with access to some signing oracle $\mathcal{O}_\sign(m)$, tries to forge a new valid message-tag pair that has never been queried before. The existential unforgeability under chosen message attack (EUF-CMA) game is shown below:

\begin{figure}[H]
    \begin{floatrow}
        \ffigbox[250px]{
            \begin{algorithm}[H]
                \caption{The EUF-CMA game}\label{alg:mac-euf-cma-game}

                \begin{algorithmic}[1]
                    \State $k^\ast \leftsample \mathcal{K}$
                    \State $(\hat{m}, \hat{t}) \leftsample \mathcal{A}^{\mathcal{O}_\sign}()$
                    \State \Return $
                        \llbrack \verify(k^\ast, \hat{m}, \hat{t}) 
                        \land (\hat{m}, \hat{t}) \not\in \mathcal{O}_\sign
                        \rrbrack
                    $
                \end{algorithmic}
            \end{algorithm}
        }{\caption{The \texttt{EUF-CMA} game}}
    \end{floatrow}
\end{figure}

The advantage $\adv_\texttt{EUF-CMA}$ of the existential forgery adversary is the probability that it wins the EUF-CMA game.

We are also interested in one-time MAC, whose security goals are identical to normal MAC, except the signing oracle will only answer one signing query. In practice this means that the adversary only gets to see one message-tag pair, and the owner of the secret key only signs one message. One way to construct an unforgeable one-time MAC is to use a universal hash function (UHF), which computes the digest using finite field arithmetic. Each instance of the one-time MAC is parameterized by some maximal message length $L$ and the finite field $\mathbb{F}$ in which arithmetics are performed. The tag is computed by evaluating a polynomial whose coefficients are derived from the message:

\begin{equation*}
    \begin{aligned}
    &H(k_1, (m_1, m_2, \ldots, m_l)) = k_1^{l+1} + k_1^{l}m_1 + k_1^{l-1}m_2 + \ldots + k_1m_l \\
    &\mac((k_1, k_2), m) = H(k_1, m) + k_2
    \end{aligned}
\end{equation*}

We claim without proof (though proof can be found in \cite{boneh2020graduate}) that the MAC construction above is one-time existentially unforgeable.

\subsection{Related works}
The Fujisaki-Okamoto transformation (FOT) \cite{fujisaki1999secure} is a generic transformation that takes a $\pke$ with weaker security (such as \texttt{OW-CPA} or \texttt{IND-CPA}) and outputs a $\pke$ with stronger security. A later variation \cite{hofheinz2017modular} improved the original construction in \cite{fujisaki1999secure} by accounting for decryption failures, tightening security bounds, and providing a modular construction that first transforms \texttt{OW-CPA}/\texttt{IND-CPA} $\pke$ into \texttt{OW-PCVA} $\pke$ by providing ciphertext integrity through re-encryption (the \texttt{T} transformation), then transforming the \texttt{OW-PCVA} $\pke$ into an \texttt{IND-CCA} $\kem$ (the \texttt{U} transformation).

% TODO: Restating the algorithm seems redundant

Particularly relevant to our results are two variations of the \texttt{U} transformation: $\texttt{U}^\bot$ (KEM with explicit rejection) and $\texttt{U}^{\not\bot}$ (KEM with implicit rejection). If $\pke$ is \texttt{OW-PCVA} secure, then $\texttt{U}^\bot$ transforms $\pke$ into an \texttt{IND-CCA} secure $\kem^\bot$:

\begin{theorem}\label{thm:u-bot}
    For any \texttt{IND-CCA} adversary $\mathcal{A}_\kem$ against $\kem^\bot$ with advantage $\epsilon_\kem$ issuing at most $q_D$ decapsulation queries and at most $q_H$ hash queries, there exists an \texttt{OW-PCVA} adversary $\mathcal{A}_\pke$ against the underlying $\pke$ with advantage $\epsilon_\pke$ that makes at most $q_H$ queries to $\pco$ and $\cvo$ such that

    \begin{equation*}
        \epsilon_\kem \leq \epsilon_\pke
    \end{equation*}
\end{theorem}

Similarly, if $\pke$ is \texttt{OW-PCA} secure, then $\texttt{U}^{\not\bot}$ transforms $\pke$ into an \texttt{IND-CCA} secure $\kem^{\not\bot}$

\begin{theorem}\label{thm:u-notbot}
    For any \texttt{IND-CCA} adversary $\mathcal{A}_\kem$ against $\kem^{\not\bot}$ with advantage $\epsilon_\kem$ issuing at most $q_D$ decapsulation queries and at most $q_H$ hash queries, there exists an \texttt{OW-CPA} adversary $\mathcal{A}_\pke$ against the underlying $\pke$ with advantage $\epsilon_\pke$ issuing at most $q_H$ queries to $\pco$ such that:

    \begin{equation*}
        \epsilon_\kem \leq \frac{q_H}{\norm{\mathcal{M}_\pke}} + \epsilon_\pke
    \end{equation*}
\end{theorem}

The modularity of the \texttt{T} and \texttt{U} transformation allows us to tweak only the \texttt{T} transformation (see section \ref{sec:main-results}), obtain \texttt{OW-PCVA} security, then automatically get \texttt{IND-CCA} security for free. This means that we can directly apply our contribution to existing KEM's already using this modular transformation, such as ML-KEM \cite{key2023mechanism}, and obtain performance improvements while maintaining comparable levels of security (see section \ref{sec:mac-performance}).

\section{The ``encrypt-then-MAC'' transformation}\label{sec:main-results}
Let $\pke(\keygen, \encrypt, \decrypt)$ be a public-key encryption scheme. Let $\mac$ be a deterministic message authentication code. Let $G: \mathcal{M}_\pke \rightarrow \mathcal{K}_\mac$ and $H: \{0,1\}^\ast \rightarrow \mathcal{K}_\kem$ be hash functions, where $\mathcal{K}_\kem$ denote the set of all possible session keys. The $\etm$ transformation outputs a key encapsulation mechanism $\kem_\etm(\keygen_\etm, \encap_\etm, \decap_\etm)$. The three routines are described in figure \ref{fig:etm-routines}.

\begin{figure}[H]
    \center
    \begin{algorithm}[H]
        \caption{$\keygen_\etm$}\label{alg:etm-keygen}
        \begin{algorithmic}[1]
            \State $(\pk, \sk_\pke) \leftsample \keygen(1^\lambda)$
            \State $z \leftsample \mathcal{M}_\pke$
            \State $\sk \leftarrow (\sk_\pke, z)$
            \State \Return $(\pk, \sk)$
        \end{algorithmic}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{$\encap_\etm(\pk)$}\label{alg:etm-encap}
        \begin{algorithmic}[1]
            \State $m \leftsample \mathcal{M}_\pke$
            \State $k \leftarrow G(m)$
            \State $c_\pke \leftsample \encrypt(\pk, m)$
            \State $t \leftarrow \mac(k, c_\pke)$
            \State $K \leftarrow H(m, c_\pke)$
            \State $c \leftarrow (c_\pke, K)$
            \State \Return $(c, K)$
        \end{algorithmic}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{$\decap_\etm(\sk, c)$}\label{alg:etm-decap}
        \begin{algorithmic}[1]
            \State $(c_\pke, t) \leftarrow c$
            \State $(\sk_\pke, z) \leftarrow \sk$
            \State $\hat{m} \leftarrow \decrypt(\sk_\pke, c_\pke)$
            \State $\hat{k} \leftarrow G(\hat{m})$
            \If{$\mac(\hat{k}, c_\pke) \neq t$}
                \State \Return $H(z, c_\pke)$
            \EndIf
            \State \Return $H(\hat{m}, c_\pke)$
        \end{algorithmic}
    \end{algorithm}
    \caption{$\kem_\etm$ routines}\label{fig:etm-routines} 
\end{figure}

\begin{theorem}\label{thm:ow-pca-implies-kem-ind-cca2}
    For every \texttt{IND-CCA2} adversary $A$ against $\kem_\etm$ that makes $q_D$ decapsulation queries, there exists an \texttt{OW-PCA} adversary $B$ who makes at least $q_D$ plaintext-checking queries against the underlying $\pke$ such that

    \begin{equation*}
        \texttt{Adv}_\texttt{IND-CCA2}(A) \leq q_D \cdot \epsilon_\mac + 2 \cdot \texttt{Adv}_\texttt{OW-PCA}(B)
    \end{equation*}
\end{theorem}

\begin{proof}
    We will prove using a sequence of games. The complete sequence of games is shown in figure \ref{fig:sequence-of-games}

    \begin{figure}[H]
        \centering
        \begin{algorithm}[H]
            \caption{Sequence of games $G_0 - G_3$}\label{alg:sequence-of-games}
            \begin{algorithmic}[1]
                \State $(\pk, \sk) \leftsample \keygen(1^\lambda)$
                \State $(m^\ast, z) \leftsample \mathcal{M}_\pke$
                \State $k^\ast \leftarrow G(m^\ast)$
                    \Comment{$G_0$-$G_1$}
                \State $k^\ast \leftsample \mathcal{K}_\mac$
                    \Comment{$G_2$-$G_3$}
                \State $c^\ast_\pke \leftsample \encrypt(\pk, m^\ast)$
                \State $t^\ast \leftarrow \mac(k^\ast, c^\ast_\pke)$
                \State $c^\ast \leftarrow (c^\ast_\pke, t^\ast)$
                \State $K_0 \leftarrow H(m^\ast, c^\ast_\pke)$
                    \Comment{$G_0$-$G_2$}
                \State $K_0 \leftsample \mathcal{K}_\kem$
                    \Comment{$G_3$}
                \State $K_1 \leftsample \mathcal{K}_\kem$
                \State $b \leftsample \{0,1\}$
                \State $\hat{b} \leftarrow A^{\mathcal{O}^\decap}(
                    1^\lambda, \pk, c^\ast, K_b)$
                    \Comment{$G_0$}
                \State $\hat{b} \leftarrow A^{\mathcal{O}^\decap_1}(
                    1^\lambda, \pk, c^\ast, K_b)$
                    \Comment{$G_1$-$G_3$}
                \State \Return $\llbrack \hat{b} = b \rrbrack$
            \end{algorithmic}
        \end{algorithm}
        \begin{algorithm}[H]
            \caption{$\mathcal{O}^\decap(c)$}\label{alg:etm-decap-oracle}
            \begin{algorithmic}[1]
                \State $(c_\pke, t) \leftarrow c$
                \State $\hat{m} \leftarrow \decrypt(\sk_\pke, c_\pke)$
                \State $\hat{k} \leftarrow G(\hat{m})$
                \If{$\mac(\hat{k}, c_\pke) = t$}
                    \State \Return $H(\hat{m}, c_\pke)$
                \EndIf
                \State \Return $H(z, c_\pke)$
            \end{algorithmic}
        \end{algorithm}
        \begin{algorithm}[H]
            \caption{$\mathcal{O}^\decap_1(c)$}\label{alg:etm-decap-oracle-1}
            \begin{algorithmic}[1]
                \State $(c_\pke, t) \leftarrow c$
                \If{$\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G 
                    : \decrypt(\sk_\pke, c_\pke) = \tilde{m} 
                    \land \mac(\tilde{k}, c_\pke) = t$}
                    \State \Return $H(\tilde{m}, c_\pke)$
                \EndIf
                \State \Return $H(z, c_\pke)$
            \end{algorithmic}
        \end{algorithm}
        \caption{Sequence of games, true decap oracle $\mathcal{O}^\decap$ and simulated oracle $\mathcal{O}^\decap_1$}\label{fig:sequence-of-games}
    \end{figure}

    \emph{Game 0} is the standard \texttt{IND-CCA2} game for a key encapsulation mechanism.

    \emph{Game 1} is identical to \emph{Game 0} except for that the decapsulation oracle $\mathcal{O}^\decap$ (algorithm \ref{alg:etm-decap-oracle}) is replaced with a simulated decapsulation oracle $\mathcal{O}^\decap_1$ (algorithm \ref{alg:etm-decap-oracle-1}). If $\mathcal{O}^\decap_1$ accepts the queried ciphertext $c = (c_\pke, t)$ and outputs the true session key $K \leftarrow H(\tilde{m}, c_\pke)$, then the queried ciphertext must be honestly generated, which means that $\mathcal{O}^\decap$ must also accept the queried ciphertext and output the true session key. If $\mathcal{O}^\decap$ rejects the queried ciphertext $c = (c_\pke, t)$ and outputs the implicit rejection $K \leftarrow H(z, c_\pke)$, then the tag $t$ is invalid under the MAC key $k \leftarrow G(\decrypt(\sk_\pke, c_\pke))$. Since for a given ciphertext $c_\pke$, the correct MAC key is fixed, there could not be a matching hash query $(m, k)$ such that $m$ is the correct decryption and $k$ can validate the incorrect tag. Therefore, $\mathcal{O}^\decap_1$ must also reject the queried ciphertext and output the implicit rejection.

    This means that game 0 and game 1 differ when $\mathcal{O}^\decap$ accepts the queried ciphertext $c = (c_\pke, t)$ but $\mathcal{O}^\decap_1$ rejects it, which means that $t$ is a valid tag for $c_\pke$ under the correct MAC key $k \leftarrow G(\decrypt(\sk_\pke, c_\pke))$ but such key is never queried by the adversary. Under the random oracle model, from the adversary's perspective, such $k$ is an unknown and uniformly random key, so producing a valid tag under such key constitutes a forgery against the MAC. Denote the probability of forgery against unknown uniformly random MAC key by $\epsilon_\mac$, then the probability that the two decapsulation oracles disagree on one or more queries is at most $q_D \cdot \epsilon_\mac$. Finally, by the difference lemma,

    \begin{equation*}
        \texttt{Adv}_0(A) - \texttt{Adv}_1(A) \leq q_D \cdot \epsilon_\mac
    \end{equation*}

    Note that $\epsilon_\mac$ quantifies the probability that an adversary can produce forgery for a unknown key without access to a signing oracles. While this is not a standard security definition for MAC, this probability is straightforward to estimate for some classes of MACs. As will be discussed in section \ref{sec:mac-performance}, with a Carter-Wegman-like one-time MAC instantiated with message length $L$ and a finite field with $F$ elements, such probability is at most $\epsilon_\mac \leq \frac{L+1}{F}$

    \emph{Game 2} is identical to \emph{Game 1}, except for that when the challenger generates the challenge ciphertext $c^\ast = (c^\ast_\pke, t^\ast)$, the tag $t^\ast$ is computed using a uniformly random key $k^\ast \leftarrow \mathcal{K}_\mac$ instead of a pseudorandom key derived from hashing the challenge plaintext.

    Under the random oracle model, game 2 and game 1 are statistically identical to the adversary $A$, unless $A$ queries $G$ with $m^\ast$. Denote the probability that $A$ queries $G$ with $m^\ast$ by $P[\texttt{QUERY G}^\ast]$, then:

    \begin{equation*}
        \texttt{Adv}_1(A) - \texttt{Adv}_2(A) \leq P[\texttt{QUERY G}^\ast]
    \end{equation*}

    \emph{Game 3} is identical to \emph{Game 2}, except for that $K_0$ is a uniformly random session key instead of a pseudorandom session key derived from the challenge plaintext-ciphertext pair. Under the random oracle model, game 3 and game 2 are statistically identical unless the adversary $A$ queries $H$ with $(m^\ast, \cdot)$. Denote the probability that $A$ makes such $H$ query by $P[\texttt{QUERY H}^\ast]$, then:

    \begin{equation*}
        \texttt{Adv}_2(A) - \texttt{Adv}_3(A) \leq P[\texttt{QUERY H}^\ast]
    \end{equation*}

    In game 3, both $K_0$ and $K_1$ are uniformly random. There is no statistical difference between the two session keys, so no adversary can have any advantage: $\texttt{Adv}_3(A) = 0$.

    Now consider an \texttt{OW-PCA} adversary $B$ simulating game 3 for $A$: \begin{enumerate}
        \item When $B$ receives its public key $\pk$, $B$ passes $\pk$ to $A$
        \item $B$ can sample the implicit rejection $z$ by itself
        \item $B$ can simulate both hash oracles $G$ and $H$ for $A$
        \item $B$ can simulate $\mathcal{O}^\decap_1$ for $A$. Instead of checking if $\decrypt(\sk_\pke, c) = \tilde{m}$, $B$ can use its access to the plaintext-checking oracle and check if $\pco(\tilde{m}, c) = 1$. This means that for every decapsulation query $B$ services, $B$ needs to make at least one plaintext-checking query. Therefore, $B$ needs to make at least $q_D$ plaintext-checking query.
        \item When $B$ receives its challenge ciphertext $c_\pke^\ast$, it can sample a uniformly random key $k^\ast \leftsample \mathcal{K}_\mac$, produce the corresponding tag $t^\ast \leftarrow \mac(k^\ast, c^\ast_\pke)$, and sample a uniformly random session keys $K_0, K_1 \leftsample \mathcal{K}_\kem$. $B$ then passes $c^\ast = (c^\ast_\pke, t^\ast)$ as the challenge ciphertext and a coin-flip $K_b$ as the challenge session key.
    \end{enumerate}

    If $A$ ever queries $G$ or $H$ with the decryption of $c^\ast_\pke$, $B$ will be able to detect it using the plaintext-checking oracle. From where $B$ is guaranteed to win the \texttt{OW-PCA} game. Therefore:

    \begin{equation*}
        \begin{aligned}
            P[\texttt{QUERY G}^\ast] &\leq \texttt{Adv}_\texttt{OW-PCA}(B) \\
            P[\texttt{QUERY H}^\ast] &\leq \texttt{Adv}_\texttt{OW-PCA}(B)
        \end{aligned}
    \end{equation*}

    Combining all inequalities above, we have:

    \begin{equation*}
        \texttt{Adv}_0(A) \leq q_D \cdot \epsilon_\mac + 2 \texttt{Adv}_\texttt{OW-PCA}(B)
    \end{equation*}
\end{proof}

%%%%%%%%%%%%%%%% uncomment to see %%%%%%%%%%%%%%%%%%%%
% \include{not-pca-means-not-indcca}

\section{Application to Kyber}\label{sec:experimental-results}
CRYSTALS-Kyber \cite{bos2018crystals}\cite{avanzi2019crystals} is an IND-CCA2 secure key encapsulation mechanism that first constructs an IND-CPA secure public key encryption scheme whose security is based on the Module Learning with Error Problem (MLWE), then applies a generic transformation using \emph{de-randomization} and \emph{re-encryption} \cite{hofheinz2017modular}. The use of \emph{re-encryption} for providing rigidity means that the decapsulation routine needs to run the encryption routine for verifying ciphertext integrity. Unfortunately for Kyber, the encryption routine consumes both more CPU cycles and carries a larger memory footprint. Therefore, applying an alternate transformation that replaces \emph{re-encryption} with a MAC verification will bring substantial performance enhancement. This is particularly applicable to communication protocols such as TLS 1.3, where clients, often constrained environments, need to run the decapsulation routine.

The \texttt{IND-CPA} PKE of Kyber (algorithms 4, 5, 6 in \cite{avanzi2019crystals}) is not \texttt{OW-PCA} secure. A plaintext-checking attack \cite{ravi2019generic} can recover the secret key using a few maliciously constructed plaintext-checking queries for each coefficient of a Kyber secret key (there are 512, 768, and 1024 coefficients in the secret key depending on the desired security level). However, we propose mitigation for plaintext-checking attack at protocol level by requiring each keypair to be used for decryption only once. If a decryption fails, then the secret key should be discarded and the key exchange terminated, and a new keypair should be generated to restart the key exchange. In fact, such ephemeral key exchange is already required in TLS 1.3 for forward secrecy, so requiring the one-time use of keypair does not introduce additional operational cost for protocols such as TLS 1.3.

The routines of \texttt{CCAKEM} can be found in Algorithm 7, 8, 9 in \cite{avanzi2019crystals}. We modify Algorithms 8 and 9 using authenticated encryption (AE)  mode as follows where Algorithm 7 is unchanged.

\begin{algorithm}[H]
    \caption{\texttt{Kyber.CCAKEM.KeyGen()}}\label{alg:kyber-ae-keygen}
    \begin{algorithmic}[1]
        \State $z \leftsample \mathcal{B}^{32}$
        \State $(\pk, \sk^\prime) \leftsample \texttt{Kyber.CPAPKE.KeyGen()}$
        \State $\sk = (\sk^\prime, \pk, H(\pk), z)$
            \Comment{H is instantiated with SHA3-256}
        \State \Return $(\pk, \sk)$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{\texttt{Kyber.CCAKEM.Encap$^+$(\pk)}}\label{alg:kyber-ae-encap}
    \begin{algorithmic}[1]
        \State $m \leftsample \mathcal{B}^{32}$
        \State $m'= H(m)$
            \Comment{Do not output system RNG directly}
        \State $(\bar{K}, K_\mac) = G(m' \Vert H(\pk))$
            \Comment{G is instantiated with SHA3-512}
        \State $r \leftsample \mathcal{R}$
        \State $c^\prime  \leftarrow \texttt{Kyber.CPAPKE.Enc}(\pk, m', r)$
            \State $t=\mac(K_\mac, c^\prime)$
        \State $K = \texttt{KDF}(\bar{K} \Vert t)$
            \Comment{\texttt{KDF} is instantiated with Shake256}
        \State $c \leftarrow (c^\prime, t)$
        \State \Return $(c, K)$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{$\texttt{Kyber.CCAKEM.Decap}^+ (\sk, c)$}\label{alg:kyber-ae-decap}
    \begin{algorithmic}[1]
        \Require Secret key $\sk = (\sk^\prime, \pk, H(\pk), z)$
        \Require Ciphertext $c = (c^\prime, t)$
        \State $(\sk^\prime, \pk, h, z) \leftarrow \sk$
        \State $(c^\prime, t_1) \leftarrow c$
        \State $\hat{m} = \texttt{Kyber.CPAPKE.Dec}(\sk^\prime, c^\prime)$ 
        \State $(\overline{K}, K_\mac) =   G(m^\prime \Vert h)$
        \State $\hat{t}=\mac(K_\mac, c)$
        \If{$\hat{t} = t$}
            \State $K  = \texttt{KDF}(\bar{K} \Vert t)$ 
         \Else 
            \State $K  = \texttt{KDF}(z \Vert t)$ 
        \EndIf
            \State \Return $K$
    \end{algorithmic}
\end{algorithm}

\begin{remark} If $c$ is manipulated, then the verification of  $t_1$  will be failed.  In this case, there is no $K$ outputted from the decap$^+$.  So the attacks described in the following subsections won't work.  We also added the key confirmation, which is tag $t_2$. 
\end{remark}


{\color{blue} Note for authenticated encryption, tags $t_i$'s are necessary for the inputs. 

In fact, this is authenticated encryption instead of EtM. So we should change that, called authenticated encryption. 
Please do not change my notation. They have their meanings in AE mode.}

% \include{when-is-etm-useful}

\subsection{MAC performance}\label{sec:mac-performance}
When instantiating an instance $\kem(\keygen, \encap, \decap)$, there are a variety of possible MAC's to choose from. For each of the security level and choice of MAC, we measured the number of CPU cycles needed to produce a digest of the unauthenticated ciphertext. The median (top) and mean (bottom) measurements are reported in table \ref{tbl:standalone-mac-perf}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Name & Security & measurement & 768 bytes & 1088 bytes & 1568 bytes \\
        \hline
        CMAC & many-time & median & 5022 & 5442 & 6090 \\
        & & mean & 5131 & 5578 & 6154 \\
        \hline
        KMAC-256 & many-time & median & 7934 & 9862 & 11742 \\
        & & mean & 8594 & 10693 & 12319 \\
        \hline
        GMAC & one-time & median & 2778 & 2756 & 2762 \\
        & & mean & 2843 & 2780 & 2919 \\
        \hline
        Poly1305 & one-time & median & 1128 & 1218 & 1338 \\
        & & mean & 1435 & 1504 & 1625 \\
        \hline
    \end{tabular}
    \caption{Standalone $\mac$ performances}\label{tbl:standalone-mac-perf}
\end{table}

Based on the security reduction in section \ref{sec:main-results} we chose standalone GMAC and Poly1305 for their substantial performance advantage over other constructions such as CBC-MAC and KMAC. We then modified the reference implementation (TODO: citation needed https://github.com/pq-crystals/kyber) according to algorithms \ref{alg:kyber-ae-keygen}, \ref{alg:kyber-ae-encap}, and \ref{alg:kyber-ae-decap}. We measured the median and mean CPU cycles needed to run each of the routines. The measurements are listed in table \ref{tbl:kyber-ae-perf}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Name & Security level & measurement & $\keygen$ & $\encap$ & $\decap$ \\
        \hline
        Kyber512 & 128 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        Kyber768 & 192 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        Kyber1024 & 256 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE512 w/ GMAC& 128 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE768 w/ GMAC& 192 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE1024 w/ GMAC& 256 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE512 w/ Poly1305& 128 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE768 w/ Poly1305& 192 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
        KyberAE1024 w/ Poly1305& 256 bits & median &  & &  \\
        & & mean &  & &  \\
        \hline
    \end{tabular}
    \caption{Kyber-AE performance measurements}\label{tbl:kyber-ae-perf}
\end{table}

\section{Conclusions and future works}\label{sec:future-works}

%%%% 8. BILBIOGRAPHY %%%%
% TODO: figure out how to use bibliography
\bibliographystyle{alpha}
\bibliography{abbrev3,crypto,biblio}
%%%% NOTES
% - Download abbrev3.bib and crypto.bib from https://cryptobib.di.ens.fr/
% - Use bilbio.bib for additional references not in the cryptobib database.
%   If possible, take them from DBLP.

\end{document}
