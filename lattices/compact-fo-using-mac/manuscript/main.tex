\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{multicol}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}
\newcommand{\keygen}{\operatorname{KeyGen}}
\newcommand{\pk}{\operatorname{pk}}
\newcommand{\sk}{\operatorname{sk}}
\newcommand{\pco}{\operatorname{PCO}}
\newcommand{\cvo}{\operatorname{CVO}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{Mermory-efficient Fujisaki-Okamoto transformation}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{OW-PCVA transformation}\label{sec:ow-pcva-transformation}
Let $(K, E, D)$ be a public-key encryption scheme defined over $(\mathcal{K}_\text{PKE}, \mathcal{M}_\text{PKE}, \mathcal{C})$. Let $(S, V)$ be a message authentication code defined over $(\mathcal{K}_\text{MAC}, \mathcal{M}_\text{MAC}, \mathcal{T})$. Let $G: \mathcal{M}_\text{PKE} \rightarrow \mathcal{K}_\text{MAC}$ be a hash function. The transformation outputs a public-key encryption scheme $(K, E_1, D_1)$. The key generation routine and key space of the transformed scheme are identical to those of the input scheme. The encryption and decryption routines of the transformed scheme are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{$E_1$}
        \SetAlgoLined
        \KwIn{
            $\pk, m \in \mathcal{M}_\text{PKE}$
        }
        $k \leftarrow G(m)$\;
        $\sigma \leftarrow E(\pk, m)$\;
        $t \leftarrow S(k, \sigma)$\;
        \Return{$c = (\sigma, t)$}\;
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{$D_1$}
        \SetAlgoLined
        \KwIn{
            $\sk, c = (\sigma \in \mathcal{C}, t \in \mathcal{T})$
        }
        $\hat{m} \leftarrow D(\sk, \sigma)$\;
        $\hat{k} \leftarrow G(\hat{m})$\;
        \If{
            $V(\hat{k}, \sigma, t) \neq 1$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

If the input PKE is deterministic, OW-CPA secure, and $\delta$-correct, and the input MAC is existentially unforgeable, then the ``encrypt-then-MAC'' PKE is OW-PCVA secure. More specifically:

\begin{theorem}\label{thm:if-ow-cpa-then-ow-pcva}
    For every OW-PCVA adversary against the transformed scheme $(E_1, D_1)$ who makes $q_G$ hash queries, $q_P$ plaintext checking queries, and $q_V$ ciphertext validation queries, and who has advantage $\epsilon_\text{OW-PCVA}$, there exists an OW-CPA adversary against the underlying PKE with advantage $\epsilon_\text{OW-CPA}$, a correctness adversary against the underlying PKE with advantage $\delta$, and a existential forgery adversary against the MAC with advantage $\epsilon_\text{MAC}$ such that:

    \begin{equation*}
        \epsilon_\text{OW-PCVA} 
        \leq (q_P + q_G) \cdot \delta
        + q_V \cdot \epsilon_\text{MAC}
        + 2 \cdot \epsilon_\text{OW-CPA}
    \end{equation*}
\end{theorem}

\begin{proof}
    To prove theorem \ref{thm:if-ow-cpa-then-ow-pcva}, we use a sequence of game.

    Game 0 is the OW-PCVA game, as described in the section above.

    In Game 1, the PCO is replaced with an alternative implementation $\pco_1$:

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\pco$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack \hat{m} = m \rrbrack$ 
                and $\llbrack V(\hat{k}, \sigma, t) \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\pco_1$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $k \leftarrow G(m)$\;
            $\hat{\sigma} \leftarrow E(\pk, m)$\;
            \Return{
                $\llbrack \sigma = \hat{\sigma} \rrbrack$
                and $\llbrack V(k, \sigma, t) \rrbrack$
            }
        \end{algorithm}
    \end{multicols}

    For any single plaintext checking query, the two oracles will disagree if and only if correctness of $(K, E, D)$ is broken, so such probability can be bounded by $\delta$. From the OW-PCVA adversary's perspective, the two games behave differently if and only if the two oracles disagree on at least one of the plaintext checking queries, which is at most $q_P \cdot \delta$:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq q_P \cdot \delta
    \end{equation*}

    In Game 2, the $\cvo$ is replaced with an alternative implementation $\cvo_1$, the latter of which checks the hash oracle's tape $\mathcal{L}^G$

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\cvo$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack V(\hat{k}, \sigma, t) = 1 \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\cvo_1$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            \If{
                $\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G$ s.t.
                $E(\pk, \tilde{m}) = c$ and $V(\tilde{k}, \sigma, t) = 1$
            }{
                \Return{$1$}\;
            }
            \Return{$0$}\;
        \end{algorithm}
    \end{multicols}

    There are two scenarios in which the two oracles can disagree. First, there is a matching hash query $(\tilde{m}, \tilde{k}) \in \mathcal{L}^G$, but $\tilde{m}$ triggers a decryption failure, so the same $\sigma$ decrypts to $\hat{m} \neq \tilde{m}$. For a single hash query, the probability of decryption error is at most $\delta$, so across $q_G$ hash queries, the probability of at least one decryption error is at most $q_G \cdot \delta$. Second, $(\sigma, t)$ is a valid message-tag pair that will pass $\cvo$, but there is no matching hash query. Under the random oracle model, from the perspective of the adversary $k \leftarrow G(m)$ is a truly random and unknown MAC key, which means that $(\sigma, t)$ is a forgery. The probability of a single ciphertet validation query being a valid forgery is bounded by the advantage of a MAC adversary, so across all $q_V$ ciphertext validation queries, the probability of having at least one valid forgery is at most $q_V\cdot\epsilon_\text{MAC}$. Finally, the probability of the two implementations disagree is at most the sum of the probabilities of the two scenarios:

    \begin{equation*}
        \epsilon_1 - \epsilon_2 \leq q_G \cdot \delta + q_V \cdot \epsilon_\text{MAC}
    \end{equation*}

    In game 3, the challenge encryption routine is modified. Instead of computing a pseudorandom MAC key $k^\ast \leftarrow G(m^\ast)$, a truly random MAC key is sampled uniformly from the message space $k^\ast \leftsample \mathcal{K}_\text{MAC}$. Under the random oracle model, game 3 and game 2 are indistinguishable from the adversary's perspective unless it makes a hash query on the value of $m^\ast$. Denote the probability that the adversary makes a hash query on $m^\ast$ by $P[\operatorname{QUERY}\ast]$, then:

    \begin{equation*}
        \epsilon_2 - \epsilon_3 \leq P[\operatorname{QUERY}\ast]
    \end{equation*}

    we can bound $P[\operatorname{QUERY}\ast]$ by constructing an OW-CPA adversary that simulates game 3 for a OW-PCVA adversary as a sub-routine. After the OW-PCVA adversary halts, the OW-CPA adversary checks through the tape of the hash oracle. Since the encryption routine is deterministic, if $m^\ast$ exists in the hash oracle tape, then it can be identified for sure. In other words, if $m^\ast$ has been queried by the OW-PCVA sub-routine, then the OW-CPA adversary can be guaranteed to win its game

    \begin{equation*}
        P[\operatorname{QUERY}\ast] = \epsilon_\text{OW-CPA}
    \end{equation*}

    Finally, game 3 can be simulated by the OW-CPA 

\end{proof}

\section{OW-PCVA transformation}
Let $(\keygen, E, D)$ define a probabilistic public-key encryption scheme, then $T$ is a transformation that takes this scheme and outputs a second public-key encryption scheme. The transformation makes use of two additional components:

\begin{enumerate}
    \item A $\operatorname{MAC}: \mathcal{K}^\text{MAC} \times \{0,1\}^\ast \rightarrow \mathcal{T}$
    \item A hash function $G: \mathcal{M} \rightarrow \text{Coin} \times \mathcal{K}^\text{MAC}$
\end{enumerate}

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA encryption $E^T$}
        \KwIn{
            $\text{pk}$, $m \in \mathcal{M}$
        }
        $(r, k) \leftarrow G(m)$\;
        $c \leftarrow E(\text{pk}, m, r)$\;
        $t \leftarrow \operatorname{MAC}(k, c)$
        \tcp*[h]{"encrypt-then-mac"}\;
        \Return{$(c, t)$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA decryption $D^T$}
        \KwIn{
            $\text{sk}, c \in \mathcal{C}, t \in \mathcal{T}$
        }
        $\hat{m} \leftarrow D(\text{sk}, c)$\;
        $(\hat{r}, \hat{k}) \leftarrow G(\hat{m})$\;
        \If{
            $\operatorname{MAC}(\hat{k}, c) \neq t$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

Instead of using re-encryption to check for the integrity of the ciphertext, a MAC tag is used. At the cost of adding a fixed number of bytes to the ciphertext, the decryption routine becomes significantly faster and memory-efficient. The memory trade-off is especially important since in Kyber, re-encryption needs to compute the entire public key $A \in R_q^{k \times k}$ from the 32-byte seed.

We claim that this transformation is still OW-PCVA. The proof will be largely similar to that of the original OW-PCVA transformation proof, but with some notable differences:

\begin{itemize}
    \item When queried on some authenticated ciphertext $(\tilde{c}, \tilde{t})$, the secret-key-less $\operatorname{CVO}_1$ searches the hash oracle $G$ for $(m, r, k)$ such that $\operatorname{MAC}(k, \tilde{c}) = \tilde{t}$. The diverging event between using $\operatorname{CVO}$ and using $\operatorname{CVO}_1$ is ``adversary produces valid authenticated ciphertext without consulting the hash oracle'', which is equivalent to selective forgery (or existential forgery, I am not sure which): $\epsilon_a - \epsilon_b \leq q_V \cdot \epsilon_\text{MAC}$
\end{itemize}

\begin{theorem}\label{mac-fo-theorem}
    Let $(\keygen, E, D)$ be a public-key encryption scheme that is $\delta$-correct and that has $\gamma$-spread. For every OW-PCVA adversary against the transformed encryption scheme $(E^T, D^T)$ that makes $q_G$ hash queries and $q_V$ ciphertext validation queries and that has advantage $\epsilon_\text{OW-PCVA}$, there exists an IND-CPA adversary against $(\keygen, E, D)$ with advantage $\epsilon_\text{IND-CPA}$ and an EF-CMA adversary against the MAC with advantage $\epsilon_\text{MAC}$ such that:

    \begin{equation*}
        \epsilon_\text{OW-PCVA}
        \leq q_G \cdot \delta 
        + q_V \cdot \epsilon_\text{MAC}
        + \frac{2q+1}{\norm{\mathcal{M}}} 
        + \epsilon_\text{IND-CPA}
    \end{equation*}
\end{theorem}

The proof will be discussed in section \ref{proof-of-mac-fo-theorem}.

\section{Proof techniques}
Similar to the 2017 paper, we will use a sequence of games to incrementally replace PCO, CVO, and other aspects of the standard OW-PCVA game with some simulation. Then we will show that the total loss of security is negligible.

\subsection{Replacing plaintext-checking oracle}\label{replacing-pco}
The plaintext-checking oracle $\operatorname{PCO}$ takes as input a plaintext-ciphertext pair $(m, (c, t))$ and return ``reject'' if and only if the the ciphertext is a valid encryption of the plaintext and vice versa under the context of some fixed keypair.

The simulated plaintext-checking oracle $\operatorname{PCO}_1$ removes the requirement for the secret key by removing the step that checks whether the queried ciphertext $(c, t)$ decrypts back to the queried plaintext $m$.

From the OW-PCVA adversary's perspective, the two oracles are indistinguishable, except for when there is a decryption error $D(\text{sk}, E(\text{pk}, m, r)) \neq m$ for the input plaintext $m$ and the corresponding coin $r$. The MAC is not involved in this argument. The loss of security is still $q_G\cdot\delta$

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Vanilla PCO}
        \KwIn{
            $m \in \mathcal{M}, c \in \mathcal{C}, t \in \mathcal{T}$ 
        }
        \If{
            $D^T(\text{sk}, (c, t)) \neq m$
        }{
            \Return{$\bot$}\;
            \tcp*[h]{Decryption did not match}
        }
        \If{
            $E^T(\text{pk}, m) \neq (c, t)$
        }{
            \Return{$\bot$}\;
            \tcp*[h]{Encryption did not match}
        }
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated $\operatorname{PCO}_1$}
        \KwIn{
            $m \in \mathcal{M}, c \in \mathcal{C}, t \in \mathcal{T}$
        }
        \If{
            $E^T(\text{pk}, m) \neq (c, t)$
        }{
            \Return{$\bot$}\;
            \tcp*[h]{Encryption did not match}
        }
    \end{algorithm}
\end{multicols}

\subsection{Replacing ciphertext-validation oracle}\label{replacing-cvo}
This is a similar trick to what was used in the 2017 paper, as well. Where the ciphertext is honestly generated, both oracles will return accept. Where the vanilla CVO rejects the ciphertext (aka ciphertext is malformed or the tag doesn't match), the simulated CVO will also reject. Therefore, the diverging event is when the vanilla CVO accepts but the simulated CVO rejects. Since the vanilla CVO accepts the query, the tag $t$ must be valid for the queried ciphertext $c$; on the other hand, the simulated CVO's rejection means there is no matching query in the hash oracle. Under the random oracle assumption, $t$ is a valid tag for some data $c$ under some key that the adversary does not know. In other words, $(c, t)$ is some kind of forgery.

\textbf{The argument on how the security of the MAC relates to this diverging event is still a bit fuzzy}, but here are two possible ways I can think of:

\begin{itemize}
    \item For each CVO query, the adversary is trying to forge tag for that specific ciphertext. This means there is a selective forgery attack, and over all $q_V$ validation queries, the probability of having at least one selective forgery attack that works is at most $q_V\epsilon_\text{SF}$
    
    \item Across all CVO query, the adversary wants to forge tag for some ciphertext, meaning there is a existential forgery attack, and the probability is at most $\epsilon_\text{EF}$
\end{itemize}

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Vanilla CVO}
        \KwIn{
            $(c \in \mathcal{C}, t \in \mathcal{T})$
        }
        \If{
            $D^T(\text{sk}, (c, t)) = \bot$
        }{
            \Return{$\bot$}\;
        }
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated $\operatorname{CVO}_1$}
        \KwIn{
            $(c \in \mathcal{C}, t \in \mathcal{T})$
        }
        \If{
            $\exists (m, r, k) \in \mathcal{O}^G$ such that $\operatorname{MAC}(k, c) = t$
        }{
            \Return{Accept}\;
        }
        \Return{$\bot$}
    \end{algorithm}
\end{multicols}

\subsection{Random until queried}\label{random-until-queried}
We then replace the pseudorandom coin and the MAC key with truly random coins and truly random keys in the challenge encryption. These two challenge encryption routines are identical, unless the adversary queries $G$ with the challenge plaintext $m^\ast$, but the probability of making such query can be bounded.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Challenge encryption}
        $m^\ast \leftsample \mathcal{M}$\;
        $(c^\ast, t^\ast) \leftarrow E^T(\text{pk}, m^\ast)$\;
        \Return{$(c^\ast, t^\ast)$}
    \end{algorithm}

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated challenge encryption}
        $m^\ast \leftsample \mathcal{M}$\;
        $r^\ast \leftsample \text{Coin}, k^\ast \leftsample \mathcal{K}_\text{MAC}$\;
        $c^\ast \leftarrow E(\text{pk}, m^\ast, r^\ast)$\;
        $t^\ast \leftarrow \operatorname{MAC}(k^\ast, c^\ast)$
        \Return{$(c^\ast, t^\ast)$}
    \end{algorithm}
\end{multicols}

Let the OW-PCVA adversary's advantage using the vanilla challenge encryption be $\epsilon_0$ and its advantage using the simulated challenge encryption be $\epsilon_1$. Denote the event that the adversary queries the hash oracle $G$ with the challenge plaintext $m^\ast$ by $\operatorname{QUERY}^\ast$, then:

\begin{equation*}
    \epsilon_0 - \epsilon_1 \leq P[\operatorname{QUERY}^\ast]
\end{equation*}

We can build an IND-CPA adversary against the underlying encryption scheme to bound $P[\operatorname{QUERY}^\ast]$: if the OW-PCVA adversary makes the magic query, then the IND-CPA adversary can find it in the hash oracle's tape and win the IND-CPA game; if the OW-PCVA adversary does not make the magic query, then the IND-CPA adversary outputs a blind guess:

\begin{equation*}
    P[\operatorname{QUERY}^\ast] \leq \epsilon_\text{IND-CPA}
\end{equation*}

\section{Complete proof of \ref{mac-fo-theorem}}\label{proof-of-mac-fo-theorem}
\begin{proof}
    We will prove using a sequence of games. Game 0 is the standard OW-PCVA game.

    Game 1 is identical to game 0, except PCO is replaced with $\operatorname{PCO}_1$, the loss of security is described in section \ref{replacing-pco}:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq q_G \cdot \delta
    \end{equation*}

    Game 2 is identical to game 1, except CVO is replaced with $\operatorname{CVO}_1$, the loss of security is described in section \ref{replacing-cvo}. Here I put a placeholder $\epsilon_\text{MAC}$ to indicate that this quantity is tied to the security of the MAC, but I don't have a solid answer yet

    \begin{equation*}
        \epsilon_1 - \epsilon_2 \leq \epsilon_\text{MAC}
    \end{equation*}

    Game 3 is identical to game 2, except the challenge encryption is replaced with the simulated challenge encryption

    \begin{equation*}
        \epsilon_3 - \epsilon_2 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    From section \ref{random-until-queried} we know that $P[\operatorname{QUERY}^\ast] \leq \epsilon_\text{IND-CPA}$ for some IND-CPA adversary against the underlying PKE.

    Game 3 can be entirely simulated by an OW-CPA adversary against the underlying PKE:

    \begin{itemize}
        \item The keypairs are identical between the two PKE's
        \item The OW-CPA adversary can simulate PCO, CVO, and hash oracle $G$
        \item The OW-CPA adversary receives challenge ciphertext $c^\ast$ which is computed from a truly random coin; it can then random a truly random MAC key and compute the tag $t^\ast$
        \item The OW-CPA adversary passes $(c^\ast, t^\ast)$ to the OW-PCVA adversary and returns whatever the OW-PCVA adversary returns
    \end{itemize}

    The OW-CPA adversary wins if and only if the OW-PCVA adversary wins: $\epsilon_3 = \epsilon_\text{OW-CPA}$.

    Putting everything together we have:

    \begin{equation*}
        \epsilon_0 
        \leq q_G \cdot \delta 
        + \epsilon_\text{MAC} 
        + \epsilon_\text{IND-CPA} 
        + \epsilon_\text{OW-CPA}
    \end{equation*}
\end{proof}

\section{Open questions}
Can we get rid of the coin and just let the encryption scheme be probabilistic? Do we need to?

\end{document}