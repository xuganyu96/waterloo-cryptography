\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{multicol}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}
% Cryptographic primitives
\newcommand{\pke}{\operatorname{PKE}}
\newcommand{\enc}{\operatorname{Enc}}
\newcommand{\dec}{\operatorname{Dec}}
\newcommand{\mac}{\operatorname{MAC}}
\newcommand{\cvo}{\operatorname{CVO}}
\newcommand{\pco}{\operatorname{PCO}}
\newcommand{\keygen}{\operatorname{KeyGen}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{Mermory-efficient Fujisaki-Okamoto transformation}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{Security definitions}

\subsection{Fujisaki-Okamoto transformation}

\section{Memory-efficient OW-PCVA transformation using MAC}
In this section we propose an alternative OW-PCVA transformation $\operatorname{T}$.

Let $\pke = (\keygen, \enc, \dec)$ be a public-key encryption scheme defined over key space $\mathcal{K}_{\pke}$, message space $\mathcal{M}$, ciphertext space $\mathcal{C}$, and coin space $\mathcal{R}$. Let $\mac = (\operatorname{Sign}, \operatorname{Verify})$ be a message authentication code defined over key space $\mathcal{K}_{\mac}$, message space $\mathcal{M}$ (the same message space as $\pke$), and tag space $\mathcal{T}$. Let $G: \mathcal{M} \rightarrow \mathcal{R} \times \mathcal{K}_{\mac}$ be a random oracle. The transformed public-key encryption scheme is denoted by $\pke_1 = T(\pke, \mac, G)$ and includes the sub-routines $(\keygen, \enc_1, \dec_1)$.

The transformed encryption and decryption routines are as follows

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA encryption $E_1$}
        \KwIn{
            $\text{pk}$, $m \in \mathcal{M}$
        }
        $(r, k) \leftarrow G(m)$\;
        $c \leftarrow E(\text{pk}, m, r)$\;
        $t \leftarrow \operatorname{MAC}(k, c)$
        \tcp*[h]{"encrypt-then-mac"}\;
        \Return{$(c, t)$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA decryption $D_1$}
        \KwIn{
            $\text{sk}, c \in \mathcal{C}, t \in \mathcal{T}$
        }
        $\hat{m} \leftarrow D(\text{sk}, c)$\;
        $(\hat{r}, \hat{k}) \leftarrow G(\hat{m})$\;
        \If{
            $\operatorname{MAC}(\hat{k}, c) \neq t$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

If $\pke$ is OW-CPA secure and $\mac$ is existentially unforgeable under chosen message attack, then the transformed encryption scheme $\pke_q$ is OW-PCVA:

\begin{theorem}
    Let $\pke$ be $\delta$-correct and have $\gamma$-spread. For every OW-PCVA adversary $\mathcal{A}_1$ against $\pke_1$ that makes $q_V$ ciphertext validation queries and $q_G$ hash queries, and that has advantage $\epsilon_1$, there exists an OW-CPA adversary against $\pke$ with advantage $\epsilon_{\pke}$ and an EF-CMA adversary against $\mac$ with advantage $\epsilon_{\mac}$ such that

    \begin{equation*}
        \epsilon_{\pke_1} \leq q_G \cdot \delta + q_V \cdot \epsilon_{\mac} + q_G \cdot \epsilon_{\pke}
    \end{equation*}
\end{theorem}

The proof follows a sequence of games that begins with the standard OW-PCVA game but incrementally replaces the PCO and the CVO with alternative implementations that can be simulated by an OW-CPA adversary and/or the EF-CMA adversary who does not have the secret key.

\begin{proof}
    Let $\mathcal{A}$ denote an adversary against the OW-PCVA security of $\enc_1$. Consider the following sequence of games.

    Game $G_0$ is the standard OW-PCVA game. In the original OW-PCVA game, queries to the random oracle $G$ are stored on a tape $\mathcal{L}^G$. By convention, we say that $G(m) = (r, k)$ if and only if $(m, r, k) \in \mathcal{L}^G$.

    We can be more explicit with the implementation of the PCO and the CVO:

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{
                Standard $\pco$ in $G_0$
            }
            \KwIn{
                $m \in \mathcal{M}, (c \in \mathcal{C}, t \in \mathcal{T})$
            }
            $\hat{m} \leftarrow \dec(\operatorname{sk}, c)$\;
            $(\hat{r}, \hat{k}) = G(\hat{m})$\;
            
            \Return{
                $\llbrack m = \hat{m} \rrbrack$ 
                and $\llbrack \mac(\hat{k}, c) = t\rrbrack$
            }
        \end{algorithm}
        
        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{
                Standard $\cvo$ in $G_0$
            }
            \KwIn{
                $c \in \mathcal{C}, t \in \mathcal{T}$
            }
            $\hat{m} \leftarrow \dec(\operatorname{sk}, c)$\;
            $(\hat{r}, \hat{k}) \leftarrow G(\hat{m})$\;
            \Return{$\llbrack \mac(\hat{k}, c) = t\rrbrack$}
        \end{algorithm}
    \end{multicols}

    Game $G_1$ is identical to $G_0$, except that the CVO is replaced with an alternative implementation. Instead of executing the decryption routine $\hat{m} \leftarrow \dec(\operatorname{sk}, (c, t))$ to recover the plaintext, the alternative implementation checks previous hash queries in $\mathcal{L}^G$ to recover the plaintext.

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{
            $\cvo_1$ in $G_1$
        }
        \KwIn{
            $(c \in \mathcal{C}, t \in \mathcal{T})$
        }
        \If{
            $\exists (m, r, k) \in \mathcal{L}^G$ such that
            $\mac(k, c) = t$
        }{
            \Return{$1$}\;
        }
        \Return{$\bot$}\;
    \end{algorithm}

    Consider a single ciphertext query $(c, t)$. If the query is accepted by $\cvo_1$, then this cipehrtext query is honestly generated, so the correctness of $\pke$ and $\mac$ implies that the query will also be accepted by $\cvo$. Similarly, if the query is rejected by $\cvo$, then either the re-encryption does not match, or the MAC does not match; in any case, $\cvo_1$ will also reject the ciphertext query. Therefore, these two implementations disagree if and only if $\cvo$ accepts the query but $\cvo_1$ rejects the query.

    Since $\cvo$ accepts the query, $t$ is a valid tag for $c$ under some MAC key $k$ derived by hashing the decryption $m \leftarrow \dec(\operatorname{sk}, c)$. Since there is no matching query in $\mathcal{L}^G$, under the random oracle assumption, the MAC key $k$ is indistinguishable from truly random. In other words, for some ciphertext $c$ of the adversary's choosing, $t$ is a forgery under an unknown key. Therefore, for a single ciphertext query, the probability that $\cvo$ and $\cvo_1$ disagree is bounded by the advantage of some existential forgery adversary: $P[\cvo(c, t) \neq \cvo_1(c, t)] \leq \epsilon_{\mac}$.

    Game 1 and game 0 behave differently if one or more among all $q_V$ ciphertext validation queries satisfies the condition above, therefore:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq q_V \cdot \epsilon_{\mac}
    \end{equation*}

    Game 2 $G_2$ is identical to $G_1$, except that the standard $\pco$ is replaced by an alternative implementation $\pco_1$

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{$\pco_1$ in $G_2$}
        \KwIn{
            $m \in \mathcal{M}, (c \in \mathcal{C}, t \in \mathcal{T})$
        }
        $(r, k) \leftarrow G(m)$\;
        \Return{
            $\llbrack \enc(\operatorname{pk}, m; r) = c \rrbrack$
            and $\llbrack \mac(k, c) = t \rrbrack$
        }
    \end{algorithm}

    % TODO: 
\end{proof}

\section{Experimental results}

\section{Open questions}
Can we get rid of the coin and just let the encryption scheme be probabilistic? Do we need to?

\end{document}