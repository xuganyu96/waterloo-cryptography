\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{multicol}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}
\newcommand{\keygen}{\operatorname{KeyGen}}
\newcommand{\pk}{\operatorname{pk}}
\newcommand{\sk}{\operatorname{sk}}
\newcommand{\pco}{\operatorname{PCO}}
\newcommand{\cvo}{\operatorname{CVO}}
\newcommand{\coin}{\operatorname{COIN}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newlength{\wdth}
\newcommand{\strike}[1]{\settowidth{\wdth}{#1}\rlap{\rule[.5ex]{\wdth}{.4pt}}#1}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{Mermory-efficient Fujisaki-Okamoto transformation}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{OW-PCVA transformation}\label{sec:ow-pcva-transformation}
Let $(K, E, D)$ be a public-key encryption scheme defined over $(\mathcal{K}_\text{PKE}, \mathcal{M}_\text{PKE}, \mathcal{C})$. Let $(S, V)$ be a message authentication code defined over $(\mathcal{K}_\text{MAC}, \mathcal{M}_\text{MAC}, \mathcal{T})$. Let $G: \mathcal{M}_\text{PKE} \rightarrow \mathcal{K}_\text{MAC}$ be a hash function. The transformation outputs a public-key encryption scheme $(K, E_1, D_1)$. The key generation routine and key space of the transformed scheme are identical to those of the input scheme. The encryption and decryption routines of the transformed scheme are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{$E_1$}
        \SetAlgoLined
        \KwIn{
            $\pk, m \in \mathcal{M}_\text{PKE}$
        }
        $k \leftarrow G(m)$\;
        $\sigma \leftarrow E(\pk, m)$\;
        $t \leftarrow S(k, \sigma)$\;
        \Return{$c = (\sigma, t)$}\;
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{$D_1$}
        \SetAlgoLined
        \KwIn{
            $\sk, c = (\sigma \in \mathcal{C}, t \in \mathcal{T})$
        }
        $\hat{m} \leftarrow D(\sk, \sigma)$\;
        $\hat{k} \leftarrow G(\hat{m})$\;
        \If{
            $V(\hat{k}, \sigma, t) \neq 1$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

If the input PKE is deterministic, OW-CPA secure, and $\delta$-correct, and the input MAC is existentially unforgeable, then the ``encrypt-then-MAC'' PKE is OW-PCVA secure. More specifically:

\begin{theorem}\label{thm:if-ow-cpa-then-ow-pcva}
    For every OW-PCVA adversary against the transformed scheme $(E_1, D_1)$ who makes $q_G$ hash queries, $q_P$ plaintext checking queries, and $q_V$ ciphertext validation queries, and who has advantage $\epsilon_\text{OW-PCVA}$, there exists an OW-CPA adversary against the underlying PKE with advantage $\epsilon_\text{OW-CPA}$, a correctness adversary against the underlying PKE with advantage $\delta$, and a existential forgery adversary against the MAC with advantage $\epsilon_\text{MAC}$ such that:

    \begin{equation*}
        \epsilon_\text{OW-PCVA} 
        \leq (q_P + q_G) \cdot \delta
        + q_V \cdot \epsilon_\text{MAC}
        + 2 \cdot \epsilon_\text{OW-CPA}
    \end{equation*}
\end{theorem}

\begin{proof}
    To prove theorem \ref{thm:if-ow-cpa-then-ow-pcva}, we use a sequence of game.

    Game 0 is the OW-PCVA game, as described in the section above.

    \begin{equation*}
        \epsilon_\text{OW-PCVA} = \epsilon_0
    \end{equation*}

    In Game 1, the PCO is replaced with an alternative implementation $\pco_1$:

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\pco$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack \hat{m} = m \rrbrack$ 
                and $\llbrack V(\hat{k}, \sigma, t) \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\pco_1$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $k \leftarrow G(m)$\;
            $\hat{\sigma} \leftarrow E(\pk, m)$\;
            \Return{
                $\llbrack \sigma = \hat{\sigma} \rrbrack$
                and $\llbrack V(k, \sigma, t) \rrbrack$
            }
        \end{algorithm}
    \end{multicols}

    For any single plaintext checking query, the two oracles will disagree if and only if correctness of $(K, E, D)$ is broken, so such probability can be bounded by $\delta$. From the OW-PCVA adversary's perspective, the two games behave differently if and only if the two oracles disagree on at least one of the plaintext checking queries, which is at most $q_P \cdot \delta$:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq q_P \cdot \delta
    \end{equation*}

    In Game 2, the $\cvo$ is replaced with an alternative implementation $\cvo_1$, the latter of which checks the hash oracle's tape $\mathcal{L}^G$

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\cvo$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack V(\hat{k}, \sigma, t) = 1 \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\cvo_1$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            \If{
                $\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G$ s.t.
                $E(\pk, \tilde{m}) = c$ and $V(\tilde{k}, \sigma, t) = 1$
            }{
                \Return{$1$}\;
            }
            \Return{$0$}\;
        \end{algorithm}
    \end{multicols}

    There are two scenarios in which the two oracles can disagree. First, there is a matching hash query $(\tilde{m}, \tilde{k}) \in \mathcal{L}^G$, but $\tilde{m}$ triggers a decryption failure, so the same $\sigma$ decrypts to $\hat{m} \neq \tilde{m}$. For a single hash query, the probability of decryption error is at most $\delta$, so across $q_G$ hash queries, the probability of at least one decryption error is at most $q_G \cdot \delta$. Second, $(\sigma, t)$ is a valid message-tag pair that will pass $\cvo$, but there is no matching hash query. Under the random oracle model, from the perspective of the adversary $k \leftarrow G(m)$ is a truly random and unknown MAC key, which means that $(\sigma, t)$ is a forgery. The probability of a single ciphertet validation query being a valid forgery is bounded by the advantage of a MAC adversary, so across all $q_V$ ciphertext validation queries, the probability of having at least one valid forgery is at most $q_V\cdot\epsilon_\text{MAC}$. Finally, the probability of the two implementations disagree is at most the sum of the probabilities of the two scenarios:

    \begin{equation*}
        \epsilon_1 - \epsilon_2 \leq q_G \cdot \delta + q_V \cdot \epsilon_\text{MAC}
    \end{equation*}

    In game 3, the challenge encryption routine is modified. Instead of computing a pseudorandom MAC key $k^\ast \leftarrow G(m^\ast)$, a truly random MAC key is sampled uniformly from the message space $k^\ast \leftsample \mathcal{K}_\text{MAC}$.

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{OW-PCVA game 2}
            \SetAlgoLined
            $(\pk, \sk) \leftarrow \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}_\text{PKE}$\;
            $k^\ast \leftarrow G(m^\ast)$\;
            $\sigma^\ast \leftarrow E(\pk, m^\ast)$\;
            $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$\;
            $c^\ast = (\sigma^\ast, t^\ast)$\;
            $\hat{m} \leftarrow \mathcal{A}_\text{OW-PCVA}^{
                \mathcal{O}^G, \pco_1, \cvo_1
            }(1^\lambda, \pk, c^\ast)$\;
            \Return{$\llbrack \hat{m} = m^\ast \rrbrack$}
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{OW-PCVA game 3}
            \SetAlgoLined
            $(\pk, \sk) \leftarrow \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}_\text{PKE}$\;
            $k^\ast \leftsample \mathcal{K}_\text{MAC}$\;
            $\sigma^\ast \leftarrow E(\pk, m^\ast)$\;
            $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$\;
            $c^\ast = (\sigma^\ast, t^\ast)$\;
            $\hat{m} \leftarrow \mathcal{A}_\text{OW-PCVA}^{
                \mathcal{O}^G, \pco_1, \cvo_1
            }(1^\lambda, \pk, c^\ast)$\;
            \Return{$\llbrack \hat{m} = m^\ast \rrbrack$}
        \end{algorithm}
    \end{multicols}
    
    
    Under the random oracle model, game 3 and game 2 are indistinguishable from the adversary's perspective unless it makes a hash query on the value of $m^\ast$. Denote the probability that the adversary makes a hash query on $m^\ast$ by $P[\operatorname{QUERY}^\ast]$, then:

    \begin{equation*}
        \epsilon_2 - \epsilon_3 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    we can bound $P[\operatorname{QUERY}^\ast]$ by constructing an OW-CPA adversary that simulates game 3 for a OW-PCVA adversary as a sub-routine. After the OW-PCVA adversary halts, the OW-CPA adversary checks through the tape of the hash oracle. Since the encryption routine is deterministic, if $m^\ast$ exists in the hash oracle tape, then it can be identified for sure. In other words, if $m^\ast$ has been queried by the OW-PCVA sub-routine, then the OW-CPA adversary can be guaranteed to win its game

    \begin{equation*}
        P[\operatorname{QUERY}^\ast] = \epsilon_\text{OW-CPA}
    \end{equation*}

    Finally, game 3 can be simulated by another OW-CPA adversary. First, all three oracles $\pco_1, \cvo_1$ and $G$ can be simulated using the same public key. When the OW-CPA challenger produces the the challenge ciphertext $\sigma^\ast \in \mathcal{C}$, the OW-CPA adversary samples a random MAC key $k^\ast \leftarrow \mathcal{K}_\text{MAC}$ and computes the tag $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$ before passing $c^\ast = (\sigma^\ast, t^\ast)$ to the OW-PCVA adversary as its challenge ciphertext. When the OW-PCVA adversary halts, the OW-CPA adversary passes OW-PCVA adversary's output as its own output. It's easy to see that the OW-CPA adversary wins if and only if the OW-PCVA adversary wins:

    \begin{equation*}
        \epsilon_3 = \epsilon_\text{OW-CPA}
    \end{equation*}

    Putting all the inequalities above together gives us the desired inequality.
\end{proof}

\subsection{Deterministic OW-CPA transformation}
In the OW-PCVA transformation, we required the input encryption scheme to be deterministic. In this section, we present a transformation that takes a probabilistic PKE and output a deterministic PKE that provides identical level of OW-CPA security.

Let $(K, E, D)$ be a PKE defined over $(\mathcal{K}, \mathcal{M}, \mathcal{C})$. We assume that the encryption routine is probabilistic and its randomness is derived from some seed $r \in \coin$. The encryption routine accepts as an argument a coin value that will be used to pseudorandomly derive all randomness in the routine. Let $H$ be a hash function $H: \mathcal{M} \rightarrow \coin$.

The transformed PKE is defined over the same spaces and shares the key generation and decryption routine with the input PKE, The only difference lies with its encryption routine:

\begin{algorithm}[H]
    \caption{$E^{\strike{\$}}$}
    \SetAlgoLined
    \KwIn{
        $(\pk, m)$
    }
    $r \leftarrow H(m)$\;
    $\sigma \leftarrow E(\pk, m; r)$\;
    \Return{$\sigma$}
\end{algorithm}

The transformed PKE is deterministic, and offers comparable level of OW-CPA security as the input PKE. More specifically:

\begin{theorem}
    For every OW-CPA adversary against the deterministic PKE $(K, E^{\strike{\$}}), D$ that makes $q_H$ hash queries to $H$ and has advantage $\epsilon_{\strike{\$}}$, there exists an OW-CPA adversary against the probabilistic PKE $(K, E, D)$ with advantage $\epsilon_\$$ such that:

    \begin{equation*}
        \epsilon_{\strike{\$}} \leq (1 + q_H) \cdot \epsilon_\$
    \end{equation*}
\end{theorem}

\begin{proof}
    We prove using a sequence of game. Denote the OW-CPA adversary against the deterministic PKE by $\mathcal{A}_{\strike{\$}}$ and its advantage by $\epsilon_{\strike{\$}}$; denote the OW-CPA adversary against the probabilistic PKE by $\mathcal{A}_\$$ and its advantage by $\epsilon_\$$
    
    Game 0 is the standard OW-CPA game: $\epsilon_0 = \epsilon_{\strike{\$}}$

    In game 1, the challenge encryption routine is modified. Instead of using a pseudorandom coin, a truly random coin is used.

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{Game 0}
            \SetAlgoLined
            $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}$\;
            $r^\ast \leftarrow H(m^\ast)$\;
            $c^\ast \leftarrow E(\pk, m^\ast; r^\ast)$\;
            $\hat{m} \leftsample \mathcal{A}_\text{OW-CPA}(1^\lambda, \pk, c^\ast)$\;
            \Return{
                $\llbrack \hat{m} = m^\ast\rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{Game 1}
            \SetAlgoLined
            $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}$\;
            $r^\ast \leftsample \coin$\;
            $c^\ast \leftarrow E(\pk, m^\ast; r^\ast)$\;
            $\hat{m} \leftsample \mathcal{A}_\text{OW-CPA}(1^\lambda, \pk, c^\ast)$\;
            \Return{
                $\llbrack \hat{m} = m^\ast\rrbrack$
            }
        \end{algorithm}
    \end{multicols}

    Under the random oracle assumption, game 0 and game 1 are indistinguishable from the perspective of $\mathcal{A}_{\strike{\$}}$ except for when $\mathcal{A}_{\strike{\$}}$ makes a hash query $\tilde{m} = m^\ast$. Denote the event that $\mathcal{A}_{\strike{\$}}$ makes such a query by $\operatorname{QUERY}^\ast$, then by the difference lemma:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    We can bound $P[\operatorname{QUERY}^\ast]$ by constructing a OW-CPA adversary against the probabilistic scheme that uses $\mathcal{A}_{\strike{\$}}$ as a sub-routine and simulates game 1 for $\mathcal{A}_{\strike{\$}}$. When $\mathcal{A}_\$$ receives the probabilistic challenge ciphertext $c^\ast$, it directly passes it to the sub-routine $\mathcal{A}_{\strike{\$}}$. After the sub-routine halts, $\mathcal{A}_\$$ samples from the hash oracle tape a random message as its output. If the sub-routine $\mathcal{A}_{\strike{\$}}$ indeed makes the correct query $m^\ast$, then the probability that a randomly chosen query value being the correct value is $\frac{1}{q_H}$:

    \begin{equation*}
        \epsilon_\$ = P[\operatorname{QUERY}^\ast] \cdot \frac{1}{q_H}
    \end{equation*}

    Game 1 can be simulated by an OW-CPA adversary against the probabilistic PKE:

    \begin{equation*}
        \epsilon_1 = \epsilon_\$
    \end{equation*}

    Putting the three equations above together gives us the desired inequality.
\end{proof}

\end{document}