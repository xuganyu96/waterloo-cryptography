\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{multicol}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}
\newcommand{\keygen}{\operatorname{KeyGen}}
\newcommand{\pk}{\operatorname{pk}}
\newcommand{\sk}{\operatorname{sk}}
\newcommand{\pco}{\operatorname{PCO}}
\newcommand{\cvo}{\operatorname{CVO}}
\newcommand{\coin}{\operatorname{COIN}}
\newcommand{\encap}{\operatorname{Encap}}
\newcommand{\decap}{\operatorname{Decap}}
\newcommand{\llbrack}{[\![}
\newcommand{\rrbrack}{]\!]}
\newlength{\wdth}
\newcommand{\strike}[1]{\settowidth{\wdth}{#1}\rlap{\rule[.5ex]{\wdth}{.4pt}}#1}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{Mermory-efficient FO transform using ``encrypt-then-MAC''}
\author{Ganyu (Bruce) Xu (g66xu)}
% \date{Fall 2023}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Preliminaries}
\subsection{Security definitions}
The security of public-key encryption schemes (PKE) and message authentication code (MAC) is defined using an number of adversarial games, where each game is defined by the adversary's goal and objectives.

For PKE, we define the $\operatorname{OW-ATK}$ and $\operatorname{IND-ATK}$ security game as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{OW-ATK security game}
        \KwIn{
            Security parameter $\lambda$, adversary $\mathcal{A}$
        }
        \SetAlgoLined
        $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
        $m^\ast \leftsample \mathcal{M}$\;
        $c^\ast \leftsample E(\pk, m^\ast)$\;
        $\hat{m} \leftarrow \mathcal{A}(1^\lambda, \pk, c^\ast, \mathcal{O}_{\operatorname{ATK}})$\;
        \Return{
            $\llbrack m = \hat{m} \rrbrack$
        }
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{IND-ATK security game}
        \KwIn{
            Security param $\lambda$, adversary $\mathcal{A}$
        }
        \SetAlgoLined
        $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
        $(m_0, m_1) \leftsample \mathcal{A}(1^\lambda, \pk, \mathcal{O}_{\operatorname{ATK}})$\;
        $b \leftsample \{0, 1\}$\;
        $c^\ast \leftarrow E(\pk, m_b)$\;
        $\hat{b} \leftarrow \mathcal{A}(1^\lambda, \pk, c^\ast, \mathcal{O}_{\operatorname{ATK}})$\;
        \Return{
            $\llbrack \hat{b} = b \rrbrack$
        }
    \end{algorithm}
\end{multicols}

Where $\mathcal{O}_{\operatorname{ATK}}$ depends on the choice of $\operatorname{ATK}$:

\begin{equation*}
    \mathcal{O}_{\operatorname{ATK}} =\begin{cases}
        - & \operatorname{ATK} = \operatorname{CPA} \\
        \pco & \operatorname{ATK} = \operatorname{PCA} \\
        \cvo & \operatorname{ATK} = \operatorname{VA} \\
        (\pco, \cvo) & \operatorname{ATK} = \operatorname{PCVA} \\
    \end{cases}
\end{equation*}

From a high level, $\pco(m, c)$ returns 1 if and only if $m$ is a valid decryption of $c$, and $\cvo(c)$ returns 1 if and only if $c$ is a valid ciphertext.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{$\pco(m, c)$}
        \Return{
            $\llbrack D(\sk, c) = m \rrbrack$
        }
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{$\cvo(c)$}
        \Return{
            $\llbrack D(\sk, c) \in \mathcal{M} \rrbrack$
        }
    \end{algorithm}
\end{multicols}

\subsection{$\delta$-correctness}
We define the correctness of a PKE using an adversarial game in which an adversary tries to produce plaintext that triggers decryption failures.

\begin{algorithm}[H]
    \caption{Correctness game $\operatorname{CORS}$}
    \SetAlgoLined
    $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
    $m \leftarrow \mathcal{A}(1^\lambda, \pk)$\;
    \Return{
        $\llbrack D(\sk, E(\pk, m)) \neq m \rrbrack$\;
    }
\end{algorithm}

\begin{definition}
    A public-key encryption scheme $\mathcal{E}=(E, D)$ is $\delta$-correct if for any efficient adversary $\mathcal{A}$, the probability of winning the correctness game is bounded by $\delta$:

    \begin{equation*}
        P[\operatorname{CORS}(\mathcal{A}) \rightarrow 1] \leq \delta
    \end{equation*}
\end{definition}

\subsection{The IND-CCA KEM transformation}
A key encapsulation mechanism (KEM) is defined by three routines $(\keygen, \encap, \decap)$, where $\keygen$ outputs a keypair $(\pk, \sk)$, $\encap$ takes the public key and outputs a pair of ciphertext $c$ and shared secret $K$, and $\decap$ takes the secret key $\sk$ and ciphertext $c$ and outputs the shared secret $K$.

The security of a KEM is defined by an adversarial game. In the IND-CCA game, the adversary has access to a decapsulation oracle $\mathcal{O}^{\decap}$ and tries to distinguish whether the challenge shared secret is pseudorandom or truly random:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{IND-CCA KEM game}
        $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
        $(c^\ast, K_0) \leftarrow \encap(\pk)$\;
        $K_1 \leftsample \mathcal{K}$\;
        $b \leftsample \{0, 1\}$\;
        $\hat{b} \leftarrow \mathcal{A}^{\mathcal{O}^{\decap}}(1^\lambda, \pk, c^\ast, K_b)$\;
        \Return{
            $\llbrack \hat{b} = b \rrbrack$
        }
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Decapsulation oracle $O^{\decap}$}
        \KwIn{$c \in \mathcal{C}$}
        \Return{
            $\decap(\sk, c)$
        }
    \end{algorithm}
\end{multicols}

The advantage of an adversary in the IND-CCA KEM game is defined by 

$$\epsilon = \norm{P[\operatorname{IND-CCA-KEM}(\mathcal{A}) = 1] - \frac{1}{2}}$$

A KEM is IND-CCA secure if for any efficient adversary, the advantage is negligible with respect to $\lambda$.

A key result from Hofheinz, Hovelmann, and Kiltz\cite{hofheinz2017modular} is a generic transformation from a PKE to a KEM. If the PKE is OW-PCVA secure, then the KEM is IND-CCA secure with tight security bounds. In this paper, we focus on the OW-PCVA transformation and use the transformation from OW-PCVA PKE to IND-CCA KEM as described by Hofheinz et al.

\section{OW-PCVA transformation}\label{sec:ow-pcva-transformation}

\subsection{From deterministic encryption scheme to OW-PCVA security}
Let $(K, E, D)$ be a public-key encryption scheme defined over $(\mathcal{K}_\text{PKE}, \mathcal{M}_\text{PKE}, \mathcal{C})$. Let $(S, V)$ be a message authentication code defined over $(\mathcal{K}_\text{MAC}, \mathcal{M}_\text{MAC}, \mathcal{T})$. Let $G: \mathcal{M}_\text{PKE} \rightarrow \mathcal{K}_\text{MAC}$ be a hash function. The transformation outputs a public-key encryption scheme $(K, E_1, D_1)$. The key generation routine and key space of the transformed scheme are identical to those of the input scheme. The encryption and decryption routines of the transformed scheme are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \caption{$E_1$}
        \SetAlgoLined
        \KwIn{
            $\pk, m \in \mathcal{M}_\text{PKE}$
        }
        $k \leftarrow G(m)$\;
        $\sigma \leftarrow E(\pk, m)$\;
        $t \leftarrow S(k, \sigma)$\;
        \Return{$c = (\sigma, t)$}\;
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{$D_1$}
        \SetAlgoLined
        \KwIn{
            $\sk, c = (\sigma \in \mathcal{C}, t \in \mathcal{T})$
        }
        $\hat{m} \leftarrow D(\sk, \sigma)$\;
        $\hat{k} \leftarrow G(\hat{m})$\;
        \If{
            $V(\hat{k}, \sigma, t) \neq 1$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

If the input PKE is deterministic, OW-CPA secure, and $\delta$-correct, and the input MAC is existentially unforgeable, then the ``encrypt-then-MAC'' PKE is OW-PCVA secure. More specifically:

\begin{theorem}\label{thm:if-ow-cpa-then-ow-pcva}
    For every OW-PCVA adversary against the transformed scheme $(E_1, D_1)$ who makes $q_G$ hash queries, $q_P$ plaintext checking queries, and $q_V$ ciphertext validation queries, and who has advantage $\epsilon_\text{OW-PCVA}$, there exists an OW-CPA adversary against the underlying PKE with advantage $\epsilon_\text{OW-CPA}$, a correctness adversary against the underlying PKE with advantage $\delta$, and a existential forgery adversary against the MAC with advantage $\epsilon_\text{MAC}$ such that:

    \begin{equation*}
        \epsilon_\text{OW-PCVA} 
        \leq (q_P + q_G) \cdot \delta
        + q_V \cdot \epsilon_\text{MAC}
        + 2 \cdot \epsilon_\text{OW-CPA}
    \end{equation*}
\end{theorem}

\begin{proof}
    To prove theorem \ref{thm:if-ow-cpa-then-ow-pcva}, we use a sequence of game.

    Game 0 is the OW-PCVA game, as described in the section above.

    \begin{equation*}
        \epsilon_\text{OW-PCVA} = \epsilon_0
    \end{equation*}

    In Game 1, the PCO is replaced with an alternative implementation $\pco_1$:

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\pco$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack \hat{m} = m \rrbrack$ 
                and $\llbrack V(\hat{k}, \sigma, t) \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\pco_1$}
            \SetAlgoLined
            \KwIn{
                $(m, c = (\sigma, t))$
            }
            $k \leftarrow G(m)$\;
            $\hat{\sigma} \leftarrow E(\pk, m)$\;
            \Return{
                $\llbrack \sigma = \hat{\sigma} \rrbrack$
                and $\llbrack V(k, \sigma, t) \rrbrack$
            }
        \end{algorithm}
    \end{multicols}

    For any single plaintext checking query, the two oracles will disagree if and only if correctness of $(K, E, D)$ is broken, so such probability can be bounded by $\delta$. From the OW-PCVA adversary's perspective, the two games behave differently if and only if the two oracles disagree on at least one of the plaintext checking queries, which is at most $q_P \cdot \delta$:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq q_P \cdot \delta
    \end{equation*}

    In Game 2, the $\cvo$ is replaced with an alternative implementation $\cvo_1$, the latter of which checks the hash oracle's tape $\mathcal{L}^G$

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{$\cvo$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            $\hat{m} \leftarrow D(\sk, \sigma)$\;
            $\hat{k} \leftarrow G(\hat{m})$\;
            \Return{
                $\llbrack V(\hat{k}, \sigma, t) = 1 \rrbrack$
            }
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{$\cvo_1$}
            \SetAlgoLined
            \KwIn{
                $c = (\sigma, t)$
            }
            \If{
                $\exists (\tilde{m}, \tilde{k}) \in \mathcal{L}^G$ s.t.
                $E(\pk, \tilde{m}) = c$ and $V(\tilde{k}, \sigma, t) = 1$
            }{
                \Return{$1$}\;
            }
            \Return{$0$}\;
        \end{algorithm}
    \end{multicols}

    There are two scenarios in which the two oracles can disagree. First, there is a matching hash query $(\tilde{m}, \tilde{k}) \in \mathcal{L}^G$, but $\tilde{m}$ triggers a decryption failure, so the same $\sigma$ decrypts to $\hat{m} \neq \tilde{m}$. For a single hash query, the probability of decryption error is at most $\delta$, so across $q_G$ hash queries, the probability of at least one decryption error is at most $q_G \cdot \delta$. Second, $(\sigma, t)$ is a valid message-tag pair that will pass $\cvo$, but there is no matching hash query. Under the random oracle model, from the perspective of the adversary $k \leftarrow G(m)$ is a truly random and unknown MAC key, which means that $(\sigma, t)$ is a forgery. The probability of a single ciphertet validation query being a valid forgery is bounded by the advantage of a MAC adversary, so across all $q_V$ ciphertext validation queries, the probability of having at least one valid forgery is at most $q_V\cdot\epsilon_\text{MAC}$. Finally, the probability of the two implementations disagree is at most the sum of the probabilities of the two scenarios:

    \begin{equation*}
        \epsilon_1 - \epsilon_2 \leq q_G \cdot \delta + q_V \cdot \epsilon_\text{MAC}
    \end{equation*}

    In game 3, the challenge encryption routine is modified. Instead of computing a pseudorandom MAC key $k^\ast \leftarrow G(m^\ast)$, a truly random MAC key is sampled uniformly from the message space $k^\ast \leftsample \mathcal{K}_\text{MAC}$.

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{OW-PCVA game 2}
            \SetAlgoLined
            $(\pk, \sk) \leftarrow \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}_\text{PKE}$\;
            $k^\ast \leftarrow G(m^\ast)$\;
            $\sigma^\ast \leftarrow E(\pk, m^\ast)$\;
            $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$\;
            $c^\ast = (\sigma^\ast, t^\ast)$\;
            $\hat{m} \leftarrow \mathcal{A}_\text{OW-PCVA}^{
                \mathcal{O}^G, \pco_1, \cvo_1
            }(1^\lambda, \pk, c^\ast)$\;
            \Return{$\llbrack \hat{m} = m^\ast \rrbrack$}
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{OW-PCVA game 3}
            \SetAlgoLined
            $(\pk, \sk) \leftarrow \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}_\text{PKE}$\;
            $k^\ast \leftsample \mathcal{K}_\text{MAC}$\;
            $\sigma^\ast \leftarrow E(\pk, m^\ast)$\;
            $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$\;
            $c^\ast = (\sigma^\ast, t^\ast)$\;
            $\hat{m} \leftarrow \mathcal{A}_\text{OW-PCVA}^{
                \mathcal{O}^G, \pco_1, \cvo_1
            }(1^\lambda, \pk, c^\ast)$\;
            \Return{$\llbrack \hat{m} = m^\ast \rrbrack$}
        \end{algorithm}
    \end{multicols}
    
    
    Under the random oracle model, game 3 and game 2 are indistinguishable from the adversary's perspective unless it makes a hash query on the value of $m^\ast$. Denote the probability that the adversary makes a hash query on $m^\ast$ by $P[\operatorname{QUERY}^\ast]$, then:

    \begin{equation*}
        \epsilon_2 - \epsilon_3 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    we can bound $P[\operatorname{QUERY}^\ast]$ by constructing an OW-CPA adversary that simulates game 3 for a OW-PCVA adversary as a sub-routine. After the OW-PCVA adversary halts, the OW-CPA adversary checks through the tape of the hash oracle. Since the encryption routine is deterministic, if $m^\ast$ exists in the hash oracle tape, then it can be identified for sure. In other words, if $m^\ast$ has been queried by the OW-PCVA sub-routine, then the OW-CPA adversary can be guaranteed to win its game

    \begin{equation*}
        P[\operatorname{QUERY}^\ast] = \epsilon_\text{OW-CPA}
    \end{equation*}

    Finally, game 3 can be simulated by another OW-CPA adversary. First, all three oracles $\pco_1, \cvo_1$ and $G$ can be simulated using the same public key. When the OW-CPA challenger produces the the challenge ciphertext $\sigma^\ast \in \mathcal{C}$, the OW-CPA adversary samples a random MAC key $k^\ast \leftarrow \mathcal{K}_\text{MAC}$ and computes the tag $t^\ast \leftarrow S(k^\ast, \sigma^\ast)$ before passing $c^\ast = (\sigma^\ast, t^\ast)$ to the OW-PCVA adversary as its challenge ciphertext. When the OW-PCVA adversary halts, the OW-CPA adversary passes OW-PCVA adversary's output as its own output. It's easy to see that the OW-CPA adversary wins if and only if the OW-PCVA adversary wins:

    \begin{equation*}
        \epsilon_3 = \epsilon_\text{OW-CPA}
    \end{equation*}

    Putting all the inequalities above together gives us the desired inequality.
\end{proof}

\subsection{From probabilistic encryption to deterministic encryption}
In the OW-PCVA transformation, we required the input encryption scheme to be deterministic. In this section, we present a transformation that takes a probabilistic PKE and output a deterministic PKE that provides identical level of OW-CPA security.

Let $(K, E, D)$ be a PKE defined over $(\mathcal{K}, \mathcal{M}, \mathcal{C})$. We assume that the encryption routine is probabilistic and its randomness is derived from some seed $r \in \coin$. The encryption routine accepts as an argument a coin value that will be used to pseudorandomly derive all randomness in the routine. Let $H$ be a hash function $H: \mathcal{M} \rightarrow \coin$.

The transformed PKE is defined over the same spaces and shares the key generation and decryption routine with the input PKE, The only difference lies with its encryption routine:

\begin{algorithm}[H]
    \caption{$E^{\strike{\$}}$}
    \SetAlgoLined
    \KwIn{
        $(\pk, m)$
    }
    $r \leftarrow H(m)$\;
    $\sigma \leftarrow E(\pk, m; r)$\;
    \Return{$\sigma$}
\end{algorithm}

The transformed PKE is deterministic, and offers comparable level of OW-CPA security as the input PKE. More specifically:

\begin{theorem}
    For every OW-CPA adversary against the deterministic PKE $(K, E^{\strike{\$}}), D$ that makes $q_H$ hash queries to $H$ and has advantage $\epsilon_{\strike{\$}}$, there exists an OW-CPA adversary against the probabilistic PKE $(K, E, D)$ with advantage $\epsilon_\$$ such that:

    \begin{equation*}
        \epsilon_{\strike{\$}} \leq (1 + q_H) \cdot \epsilon_\$
    \end{equation*}
\end{theorem}

\begin{proof}
    We prove using a sequence of game. Denote the OW-CPA adversary against the deterministic PKE by $\mathcal{A}_{\strike{\$}}$ and its advantage by $\epsilon_{\strike{\$}}$; denote the OW-CPA adversary against the probabilistic PKE by $\mathcal{A}_\$$ and its advantage by $\epsilon_\$$
    
    Game 0 is the standard OW-CPA game: $\epsilon_0 = \epsilon_{\strike{\$}}$

    In game 1, the challenge encryption routine is modified. Instead of using a pseudorandom coin, a truly random coin is used.

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{Game 0}
            \SetAlgoLined
            $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}$\;
            $r^\ast \leftarrow H(m^\ast)$\;
            $c^\ast \leftarrow E(\pk, m^\ast; r^\ast)$\;
            $\hat{m} \leftsample \mathcal{A}_\text{OW-CPA}(1^\lambda, \pk, c^\ast)$\;
            \Return{
                $\llbrack \hat{m} = m^\ast\rrbrack$
            }
        \end{algorithm}

        \columnbreak

        \begin{algorithm}[H]
            \caption{Game 1}
            \SetAlgoLined
            $(\pk, \sk) \leftsample \keygen(1^\lambda)$\;
            $m^\ast \leftsample \mathcal{M}$\;
            $r^\ast \leftsample \coin$\;
            $c^\ast \leftarrow E(\pk, m^\ast; r^\ast)$\;
            $\hat{m} \leftsample \mathcal{A}_\text{OW-CPA}(1^\lambda, \pk, c^\ast)$\;
            \Return{
                $\llbrack \hat{m} = m^\ast\rrbrack$
            }
        \end{algorithm}
    \end{multicols}

    Under the random oracle assumption, game 0 and game 1 are indistinguishable from the perspective of $\mathcal{A}_{\strike{\$}}$ except for when $\mathcal{A}_{\strike{\$}}$ makes a hash query $\tilde{m} = m^\ast$. Denote the event that $\mathcal{A}_{\strike{\$}}$ makes such a query by $\operatorname{QUERY}^\ast$, then by the difference lemma:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    We can bound $P[\operatorname{QUERY}^\ast]$ by constructing a OW-CPA adversary against the probabilistic scheme that uses $\mathcal{A}_{\strike{\$}}$ as a sub-routine and simulates game 1 for $\mathcal{A}_{\strike{\$}}$. When $\mathcal{A}_\$$ receives the probabilistic challenge ciphertext $c^\ast$, it directly passes it to the sub-routine $\mathcal{A}_{\strike{\$}}$. After the sub-routine halts, $\mathcal{A}_\$$ samples from the hash oracle tape a random message as its output. If the sub-routine $\mathcal{A}_{\strike{\$}}$ indeed makes the correct query $m^\ast$, then the probability that a randomly chosen query value being the correct value is $\frac{1}{q_H}$:

    \begin{equation*}
        \epsilon_\$ = P[\operatorname{QUERY}^\ast] \cdot \frac{1}{q_H}
    \end{equation*}

    Game 1 can be simulated by an OW-CPA adversary against the probabilistic PKE:

    \begin{equation*}
        \epsilon_1 = \epsilon_\$
    \end{equation*}

    Putting the three equations above together gives us the desired inequality.
\end{proof}

\bibliographystyle{plain}
\bibliography{./references.bib}

\end{document}