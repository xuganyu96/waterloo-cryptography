\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
% \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}

% Custom commands
\usepackage{crypto-primitives}
\usepackage{kyber-algos}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[theorem]


\title{
    Handshake workflow in TLS 1.2 vs 1.3
}
\author{
    Ganyu (Bruce) Xu
}
% Leave the date field empty to display the date of compilation
% \date{}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Handshake workflow in TLS 1.2 (RFC 5246)}
TLS 1.2 supports three main key exchange workflows: long-term Diffie-Hellman (DH and ECDH), RSA, and ephemeral Diffie-Hellman (DHE and ECDHE). Depending on the choice of key exchange method, the handshake workflow may vary, but there are three invariants: \begin{itemize}
    \item Some key exchange so client and server can establish shared secret over insecure channel
    \item Server needs to authenticate itself by presenting some kind of public key signed by a certificate authority, then prove posession of the corresponding secret key
    \item Some kind of key confirmation to confirm that client and server indeed have the same secret
\end{itemize}

\subsection{With long-term Diffie-Hellman}
\begin{enumerate}
    \item \textbf{Client sends \texttt{ClientHello}}: \\ in \texttt{ClientHello}, client specifies that it supports \texttt{DH\_*} for key exchange
    \item \textbf{Server responds with \texttt{ServerHello}} \\ in \texttt{ServerHello}, server chooses \texttt{DH\_*} for key exchange
    \item \textbf{Server sends \texttt{Certificate}} \\ \texttt{Certificate} contains server's Diffie-Hellman parameters $g^y$ signed by the certificate authority (RFC 5246 A.5). Also note that with a \texttt{DH\_*} key exchange, \textit{server must not send \texttt{ServerKeyExchange}}, or the client will abort the handshake (7.4.3) 
    \item \textbf{Client sends \texttt{ClientKeyExchange}} \\ \texttt{ClientKeyExchange} contains client's Diffie-Hellman parameters. \\ After server receives \texttt{ClientKeyExchange}, client and server have agreed on a pre-master secret, and the handshake traffic keys are derived from pre-master secret. 
    \item \textbf{Client and server send each other \texttt{Finished}} \\ \texttt{Finished} contains a MAC over all previous messages signed using a secret key derived from the pre-master secret.
\end{enumerate}

With long-term Diffie-Hellman, \textbf{server authentication is implicit}. Server demonstrates possession of the Diffie-Hellman secret key that correspond to the public key in \texttt{Certificate} by correctly computing the shared secret, then use the shared secret to compute a valid tag, which is presented in \texttt{Finished}. If the server does not have the corresponding secret key, then it cannot produce a valid tag, so the client will abort the handshake after receiving an invalid \texttt{Finished} from the server.

\subsection{With RSA}
\begin{enumerate}
    \item \textbf{Client sends \texttt{ClientHello}}: \\ in \texttt{ClientHello}, client specifies that it supports \texttt{RSA\_*} for key exchange
    \item \textbf{Server responds with \texttt{ServerHello}} \\ in \texttt{ServerHello}, server chooses \texttt{RSA\_*} for key exchange
    \item \textbf{Server sends \texttt{Certificate}} \\ \texttt{Certificate} contains server's RSA public key (an encryption key) signed by the certificate authority (RFC 5246 A.5). Similar to long-term Diffie-Hellman key exchange, \textit{server must not send \texttt{ServerKeyExchange}}.
    \item \textbf{Client sends \texttt{ClientKeyExchange}} \\ \texttt{ClientKeyExchange} contains the RSA ciphertext generated by the client using the server's public key in the certificate. \\ After server receives \texttt{ClientKeyExchange}, client and server have agreed on a pre-master secret.
    \item \textbf{Client and server send each other \texttt{Finished}} \\ \texttt{Finished} contains a MAC over all previous messages signed using a secret key derived from the pre-master secret.
\end{enumerate}

In RSA key exchange, \textbf{server authentication} is also implicit just like with long-term Diffie-Hellman key exchange.

\subsection{With ephemeral Diffie-Hellman}
\begin{enumerate}
    \item \textbf{Client sends \texttt{ClientHello}}: \\ in \texttt{ClientHello}, client specifies that it supports \texttt{DHE\_*} for key exchange
    \item \textbf{Server responds with \texttt{ServerHello}} \\ in \texttt{ServerHello}, server chooses \texttt{DHE\_*} for key exchange
    \item \textbf{Server sends \texttt{Certificate}} \\ \texttt{Certificate} contains server's public key (a digital signature signing key) signed by the certificate authority
    \item \textbf{Server sends \texttt{ServerKeyExchange}} \\ \texttt{ServerKeyExchange} contains server's ephemeral Diffie-Hellman parameters and a digital signature of these server parameters signed using server's secret key corresponding to the public key in server certificate
    \item \textbf{Client sends \texttt{ClientKeyExchange}} \\ contains client's ephemeral Diffie-Hellman parameters 
    \item \textbf{CLient and server send each other \texttt{Finished}}
\end{enumerate}

In DHE, \textbf{server authentication is explicit}: server presents its public key (a verification key) in the server certificate, which is signed by the the certificate authority and thus bound to the server's identity. Server sends demonstrates possession of the corresponding secret key (a signing key) by signing client secret, server secret, and server DHE parameters in \texttt{ServerKeyExchange}.

\section{Key exchange workflow in TLS 1.3}
TLS 1.3 differs from 1.2 in that \textbf{TLS 1.3 deprecated all long-term Diffie-Hellman and RSA key exchange methods; ephemeral Diffie-Hellman key exchange is the only supported key exchange}. The handshake workflow thus differs from TLS 1.2.

\begin{enumerate}
    \item \textbf{Client sends \texttt{ClientHello}} \begin{itemize}
        \item The \texttt{cipher\_suites} field contains the supported set of cipher suites, but \textit{this field no longer specifies the key exchange methods}, only the AEAD scheme (AES-128-GCM, AES-256-GCM or ChaCha20-Poly1305) and HKDF (SHA256 or SHA384)
        \item The \texttt{random} field contains client's random values
        \item The \texttt{signature\_algorithms} extension specifies the type of signature the client supports for \texttt{CertificateVerify} (aka server's signature).
        \item The \texttt{signature\_algorithms\_sert} extension specifies the type of signature the client supports for \texttt{Certificate} (aka certificate authority's signature)
        \item The \texttt{supported\_group} extension specifies the Diffie-Hellman groups that the client supports
        \item The \texttt{key\_share} extension specifies client's ephemeral Diffie-Hellman parameters ($g^x$)
    \end{itemize}

    \item \textbf{Server responds with \texttt{ServerHello}} \begin{itemize}
        \item The \texttt{random} field contains server's random values
        \item The \texttt{key\_share} extension contains server's chosen Diffie-Hellman group and the corresponding ephemeral parameters
    \end{itemize}
    
    \item \textbf{Server sends \texttt{Certificate}} \\ In TLS 1.3, \textit{server's certificate must contain a digital signature's verification key}. This public key is bound to the server's identity by certificate authority's signature
    
    \item \textbf{Server sends \texttt{CertificateVerify}} \\ This message contains a signature over all handshake messages up to this point, signed using the server's secret key. \textbf{This authenticates the server explicitly}.
    
    \item Client authentication is optional in TLS. If client authentication is needed, then server requests client's certificate with \texttt{CertificateRequest}, and client respond with client's authentication messages \texttt{Certificate} and \texttt{CertificateVerify}.
    \item Client and server send each other \texttt{Finished}, which contains a MAC over the handshake transcript signed using the shared secret
\end{enumerate}

\section{Incorporating post-quantum KEM into TLS 1.3}
While there is no standardization on how post-quantum KEMs will be incorporated into TLS 1.3, Google and Cloudflare have done some \href{https://blog.cloudflare.com/the-tls-post-quantum-experiment/}{experimental implementations} in 2019. At the time the chosen KEMs were \texttt{HRSSS} and \texttt{SIKE}, though there is nothing special about these two KEMs, so any other KEM can be a drop-in replacement. The handshake workflow will be as follows:

\begin{enumerate}
    \item \texttt{ClientHello} \begin{itemize}
        \item In the \texttt{supported\_groups} extensions, add a group that indicates client's support for post-quantum (hybrid) key exchange, such as \texttt{Kyber768X25519}
        \item In the \texttt{key\_share} extension, include a key share entry whose value is the concatenation of classical and PQ public keys \texttt{key\_share = X25519\_public\_value || ephemeral\_KEM\_public\_key}
    \end{itemize}

    \item \texttt{ServerHello} \begin{itemize}
        \item In the \texttt{key\_share} extension, server's response is the concatenation of server's ephemeral Diffie-Hellman parameters and the ciphertext produced by running the encapsulation routine using client's ephemeral encapsulation key
    \end{itemize}
\end{enumerate}

The pre-master secret is derived from the concatenation of the Diffie-Hellman shared secret and the KEM shared secret.

In this setup, a fresh KEM key pair is generated by the client at each handshake, which means that each decapsulation key is used exactly once. If the decapsulation routine rejects the ciphertext explicitly, or if the client and the server's pre-master secret disagree, then somewhere along the handshake protocol the client will abort the handshake. When the handshake is restarted, another key pair will be generated. Therefore, at least in the context of TLS, \textbf{limiting a CCA adversary to exactly one decryption query} is a reasonable security goal.

\end{document}