\documentclass{article}
\usepackage[margin=1in,letterpaper]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% For source code
\usepackage{listings}

% Algorithms and pseudocode
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}

% Common shortcuts
\newcommand{\round}[1]{\lfloor {#1} \rceil}
\newcommand{\norm}[1]{\vert {#1} \vert}
\newcommand{\Norm}[1]{\Vert {#1} \Vert}
\newcommand{\var}[1]{\operatorname{Var}[{#1}]}
\newcommand{\leftsample}{\overset{{\scriptscriptstyle\$}}{\leftarrow}}

% Environments: definitions, theorems, propositions, corollaries, lemmas
%    Theorems, propositions, and definitions are numbered within the section
%    Corollaries are numbered within the theorem, though they are rarely used
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}


\title{An introduction to Fujisaki-Okamoto transformation}
\author{Ganyu (Bruce) Xu (g66xu)}
\date{CO 789, Winter 2024}

\begin{document}
%%%% TITLE %%%%%
\maketitle

\section{Introduction}
Indistinguishability under (adaptive) chosen-ciphertext attack (IND-CCA2) is widely recognized as the desirable security notion for public-key cryptography. However, directly achieving IND-CCA2 security is difficult. Previous attempts at deploying public-key cryptography in production, such as the usage of RSA PKCS1 v1.5 in early versions of SSl/TLS, were found to be vulnerable to adaptive chosen-ciphertext attacks.

Instead of directly constructing IND-CCA2 secure cryptosystem from NP-hard problems, recent works approached this problem by proposing generic transformation that take cryptographic primitives of lesser strengths (e.g. OW-CPA, IND-CPA) and produce encryption schemes that lose only a negligible amount of security. One such transformation was proposed by Fujisaki and Okamoto in 1999 and later improved by Hofheinz, Hovelmann, and Kiltz in 2017. With simple construction and robust security reduction, the FO transformation is adopted by submissions to NIST's post-quantum cryptography competition (notably by Kyber, which has been standardized in FIPS 203 in 2024).

In this paper, we will review the constructions of the Fujisaki-Okamoto transformation and its variations. We will also review their security results, including the techniques used in the security reduction. Finally, we will discuss open problems and propose some optimization.

\section{Preliminaries}
% TODO: from IND-CPA to OW-CPA

\subsection{Spread and correctness}
The spread of measures the randomness of ciphertext in a probabilistic encryption scheme, where the randomness of the encryption routine is determined by a random coin $r \leftsample \text{Coin}$ from the coin space.

\begin{definition}[$\gamma$-spread]
    The spread $\gamma$ of an asymmetric encryption scheme $(\operatorname{KeyGen}, E, D)$ for some fixed public key $\text{pk}$ and plaintext $m$ is defined by

    \begin{equation*}
        \gamma(\text{pk}, m) = -\log{\Norm{E_\text{pk}(m)}_\infty}
    \end{equation*}

    Where $\Norm{E_\text{pk}(m)}_\infty$ is the min-entropy of the ciphertext with respect to the coin:

    \begin{equation*}
        \Norm{E_\text{pk}(m)}_\infty 
        = \max_{c \in \mathcal{C}} P[E_\text{pk}(m) = c]
    \end{equation*}
\end{definition}

\begin{definition}[correctness]
    A public-key encrpytion scheme $(\operatorname{KeyGen}, E, D)$ is $\delta$-correct if across all possible keypairs and messages, the probability of decryption error is at most $\delta$:

    \begin{equation*}
        \max_{
            m \in \mathcal{M},
            (\text{pk}, \text{sk}) \leftsample \operatorname{KeyGen}()
        } P[D_\text{sk}(E_\text{pk}(m)) \neq m]
        \leq \delta
    \end{equation*}
\end{definition}

\subsection{Difference lemma}
The difference lemma is used extensively in the sequence of games to estimate the loss of security when one game is transformed into another

\begin{lemma}[Difference lemma]
    Let $A, B, F$ be events defined on the same probability space. If $P[A \cap \neg F] = P[B \cap \neg F]$, then $P[A] - P[B] \leq P[F]$
\end{lemma}

\begin{proof}
    \begin{equation*}
        \begin{aligned}
            P[A] - P[B] &= (P[A \cap F] + P[A \cap \neg F]) 
                - (P[B \cap F] + P[B \cap \neg F]) \\
            &= (P[A \cap F] - P[B \cap F]) 
                + (P[A \cap \neg F] - P[B \cap \neg F]) \\
            &= P[A \cap F] - P[B \cap F] \\
            &\leq P[A \cap F] \\
            &\leq P[F]
        \end{aligned}
    \end{equation*}
\end{proof}

In the context of security reduction using sequence of game, the difference lemma is invoked with event $A$ and $B$ set to "adversary winning one game" and "adversary winning another game", and event $F$ set to the event that would cause the two games two diverge. If the diverging event $F$ does not happen, then the two games are identical to each other, so the advantage of the adversary remains the same across the two games; if the diverging event $F$ happens, then the advantage of the adversary does not change by more than the probability of the diverging event $F$.

\subsection{IND-CPA to OW-CPA}\label{ind-cpa-to-ow-cpa}
It is trivially true that if a public-key encryption scheme is not one-way secure, then it is not indistinguishable. The converse if also almost true, with the caveat that the message space must be sufficiently large: 

\begin{lemma}
    Let $(\operatorname{KeyGen}, E, D)$ be a public-key encryption scheme with a finite message space $\mathcal{M}$. For every IND-CPA adversary $A$, there exists an OW-CPA adversary $B$ such that

    \begin{equation*}
        \epsilon_\text{OW-CPA} = \epsilon_\text{IND-CPA} + \frac{1}{\norm{\mathcal{M}}}
    \end{equation*}
\end{lemma}

\section{Related works}
\subsection{OAEP and plaintext awareness}
    One of the early attempts at an IND-CCA secure public-key encryption scheme is RSA. Unfortunately, the first deployment of RSA in PKCS\#1 v1.5 \cite{kaliski1998rfc2313} is proved vulnerable to chosen-ciphertext attacks by Bleichenbacher \cite{bleichenbacher1998chosen}. Subsequent work by Bellare and Rogaway \cite{bellare1995optimal} proposed the Optimal Asymmetric Encryption Padding (OAEP) as a generic IND-CCA secure transformation. Bellare and Rogaway argued for the IND-CCA security of OAEP through the framework of ``plaintext awareness'', which states that the ciphertext cannot be partially decrypted without inverting some cryptographic trapdoor functions. Later on OAEP is shown to be only IND-CCA1 secure, although Fujisaki, et all showed that RSA-OAEP is indeed IND-CCA2 secure \cite{fujisaki2001rsa}.

\subsection{In the context of key exchange}
    Key encapsulation mechanisms (KEM) usually have weaker security requirements than public-key encryption schemes (PKE) thanks to the fact that properly designed KEMs obfuscate the plaintext through a key-derivation function (which is usually a hash function and thus a random oracle under the RO assumption) in the decryption routine. As a result, we can implement a simple IND-CCA2 KEM using an IND-CCA2 PKE:

    % \begin{multicols}{3}
    %     \begin{algorithm}[H]
    %         \SetAlgoLined
    %         \caption{KeyGen}
    %         $(\text{pk}, \text{sk}) \leftsample \operatorname{KeyGen}()$ \;
    %         \Return{$(\text{pk}, \text{sk})$}
    %     \end{algorithm}

    %     \begin{algorithm}[H]
    %         \SetAlgoLined
    %         \caption{Encap}
    %         \KwIn{$\text{pk}$}
    %         $m \leftsample \mathcal{M}$\;
    %         $c \leftsample E(\text{pk}, m)$\;
    %         $K \leftarrow H(m, c)$\;
    %         \Return{$(c, K)$}\;
    %     \end{algorithm}

    %     \begin{algorithm}[H]
    %         \SetAlgoLined
    %         \caption{Decap}
    %         \KwIn{$\text{sk}, c \in \mathcal{C}$}
    %         $\hat{m} \leftarrow D(\text{sk}, c)$\;
    %         $\hat{K} \leftarrow H(\hat{m}, c)$\;
    %         \Return{$\hat{K}$}\;
    %     \end{algorithm}
    % \end{multicols}

    It is straightforward to simulate the KEM game using a PKE adversary. The PKE adversary samples two random messages $(m_0, m_1) \leftsample \mathcal{M}$ and obtains the challenge encryption for one of them $c^\ast \leftarrow E(\text{pk}, m_b)$. The PKE adversary then computes $K^\ast \leftarrow H(c^\ast, m_0)$ and passes $(c^\ast, K^\ast)$ as the challenge encapsulation to the KEM adversary. If $c^\ast$ is an encryption of $m_0$, then $K^\ast$ is pseudorandom, otherwise under the random oralce model, $K^\ast$ is truly random from the perspective of the KEM adversary. Therefore, $\epsilon_\text{PKE} = \epsilon_\text{KEM}$.

    Using IND-CCA2 PKE as an IND-CCA2 KEM has been in production for a long time. For example, TLS 1.2 \cite{dierks2008rfc} offers this implementation for key exchange using RSA-OAEP\cite{bellare1995optimal} as the underlying IND-CCA2 PKE. The key exchange protocol proceeds as follows:

    \begin{enumerate}
        \item Server sends its public key through the X.509 certificate
        \item Client samples a master secret, encrypts the secret using server's public key, then sends the ciphertext to the server
        \item Server decrypts the ciphertext to obtain the master secret
    \end{enumerate}

    This approach to key exchange has since been deprecated, and RSA is no longer supported for key exchange starting with TLS 1.3. In addition to the difficulty of implementing RSA correctly and securely (RSA is notoriously hard to implement without side-channel vulnerabilities), using the server's long-term keypair for establishing common secrets fails to provide forward secrecy, meaning that if the long-term key is compromised, all prior communications can be trivially decrypted.

    While the modern approach is to use ephemeral Diffie-Hellman (with either prime field or elliptic curve), it is difficult to adapt this approach to the post-quantum setting. Instead, post-quantum key exchange usually builds an IND-CCA2 KEM, then perform the key exchange using ephemeral keypairs. At each session's handshake, the client generates the a new keypair and sends the public key to the server. The server uses the public key to run the encapsulation routine and sends back the ciphertext. Finally, the client runs the decapsulation routine on the ciphertext to recover the shared secret.

\section{Fujisaki-Okamoto transformation and variations}
In 1999, Fujisaki and Okamoto \cite{fujisaki1999secure} proposed a generic transformation that outputs an IND-CCA2-secure public-key encryption scheme using an IND-CPA symmetric cipher, an OW-CPA asymmetric cipher, and two hash functions. Later on in 2017, Hofheinz, Hovelmann, and Kiltz \cite{hofheinz2017modular} improved on the security of the Fujisaki-Transformation and adapted the original approach to constructing IND-CCA2 KEMs. In this section, we will give a quick overview of the individual transformations and their security results. We will then discuss the techniques used in the security reduction. Finally, we will provide a sketch of the actual proof.

\subsection{An overview of transformed routines and security results}
The original 1999 Fujisaki-Okamoto transformation takes as input a symmetric cipher $(E^\text{sym}, D^\text{sym})$, an asymmetric cipher $(\operatorname{KeyGen}, E^\text{asym}, D^\text{asym})$, a key derivation function (aka a hash function) $G: \mathcal{M}^\text{asym} \rightarrow \mathcal{K}^\text{sym}$, and a hash functino $H: \{0, 1\}^\ast \rightarrow \text{Coin}^\text{asym}$.

Specifically, the asymmetric cipher is assumed to be probabilistic, but with pseudorandomness seeded on some coin $r \in \text{Coin}^\text{asym}$. When $E^\text{asym}$ is called without specifying a value for coin, it is assumed that a coin is uniformly sampled from the coin space and passed in as the pseudorandom seed:

$$
    c \leftsample E^\text{asym}(\text{pk}, m) 
    \Leftrightarrow 
    c \leftarrow E^\text{asym}(\text{pk}, m, r \leftsample \text{Coin})
$$

The output of the transformation is a public-key encryption scheme $(\operatorname{KeyGen}, E^\text{hy}, D^\text{hy})$. Note that the key generation routine is exactly the same as the input asymmetric cipher's routine, so no distinction of notation is needed. The encryption and decryption routines are as follows:

% \pagebreak

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Hybrid encryption $E^\text{hy}$}
        \KwIn{$\text{pk}, m \in \mathcal{M}^\text{sym}$}
        $\sigma \leftsample \mathcal{M}^\text{asym}$\;
        $a \leftarrow G(\sigma)$; $c \leftarrow E^\text{sym}_a(m)$\;
        $r \leftarrow H(\sigma, c)$;
        $e \leftarrow E^\text{asym}(\text{pk}, m, r)$\;
        \Return{$(c, e)$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]\label{hybrid-decryption-99}
        \SetAlgoLined
        \caption{Hybrid decryption $D^\text{hy}$}
        \KwIn{$\text{sk}, c \in \mathcal{C}^\text{sym}, e \in \mathcal{C}^\text{asym}$}
        $\hat{\sigma} \leftarrow D^\text{asym}(\text{sk}, e)$\;
        $\hat{r} \leftarrow H(\hat{\sigma}, c)$\;
        \If{
            $E^\text{asym}(\text{pk}, \hat{\sigma}, \hat{r}) \neq e$
        }{
            \Return{$\bot$}; \tcp*[h]{the "re-encryption"}
        }
        $\hat{a} \leftarrow G(\hat{\sigma})$\;
        $\hat{m} \leftarrow D^\text{sym}_{\hat{a}}(c)$\;
        \Return{$\hat{m}$}\;
    \end{algorithm}
\end{multicols}

\begin{theorem}[Security result for $(E^\text{hy}, D^\text{hy})$]\label{fo-1999-theorem}
    If the input asymmetric cipher has $\gamma$ spread, then for every IND-CPA adversary $\mathcal{A}^\text{sym}_\text{IND-CPA}$ against the underlying symmetric cipher with advantage $\epsilon^\text{sym}$ and OW-CPA adversary $\mathcal{A}^\text{asym}_\text{OW-CPA}$ against the input asymmetric cipher with advantage $\epsilon^\text{asym}$, there exists an IND-CCA2 adversary with against the hybrid scheme making $q_H$ hash queries and $q_D$ decryption queries such that:

    \begin{equation*}
        \epsilon^\text{hy} 
        \leq q_D2^{-\gamma} 
            + \epsilon^\text{sym} 
            + q_H\epsilon^\text{asym}
    \end{equation*}
\end{theorem}

Hofheinz, Hovenmann, and Kiltz pointed out in their 2017 paper a number of drawbacks of the original FO transformation:

\begin{enumerate}
    \item Decryption error, which is especially possible with lattice-based schemes, is not accounted for
    \item the $q_H\epsilon^\text{asym}$ term causes security to be non-tight, which have implications when choosing the security parameters
\end{enumerate}

In their proposals, IND-CCA2 security is achieved through a two-step transformation. First, an OW-CPA asymmetric scheme is transformed into an OW-PCVA asymmetric scheme. The OW-PCVA scheme is then transformed into an IND-CCA2 KEM. Here PCVA refers to the adversary's ability to access some plaintext-checking oracle and some ciphertext validation oracle. Although PCVA is a non-standard security definition, it is entirely contained within the two-step transformation and serves only as an intermediary step.

Neither the OW-PCVA nor the IND-CCA transformation makes use of any symmetric cipher, so we ditch the distinction. The OW-PCVA transformation takes as input an asymmetric cipher $(E, D)$ and a hash function $G: \mathcal{M} \rightarrow \text{Coin}$. The transformed encryption and decryption routines $(E^T, D^T)$ are as follows:

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA $E^T$}
        \KwIn{$\text{pk}, m \in \mathcal{M}$}
        $r \leftarrow G(m)$\;
        $c \leftarrow E(\text{pk}, m, r)$\;
        \Return{$c$}\;
    \end{algorithm}

    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{OW-PCVA $D^T$}
        \KwIn{$\text{sk}, c \in \mathcal{C}$}
        $\hat{m} \leftarrow D(\text{sk}, c)$\;
        $\hat{r} \leftarrow G(\hat{m})$\;
        \If{
            $E(\text{pk}, \hat{m}, \hat{r}) \neq c$
        }{
            \Return{$\bot$}\;
        }
        \Return{$\hat{m}$};
    \end{algorithm}
\end{multicols}

Depending on whether the implementation chooses implicit or explicit rejection of invalid ciphertext for the final KEM, the second transformation has slightly different key generation and decryption routine. The explicit rejection KEM is denoted by $U^\bot$, and its key generation is identical to the input asymmetric cipher.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{$U^\bot$ Encap}
        \KwIn{$\text{pk}$}
        $m \leftsample \mathcal{M}$\;
        $c \leftarrow E^T(\text{pk}, m)$\;
        $K \leftarrow H(m, c)$ \tcp*[h]{H is a hash function}\;
        \Return{$(c, K)$}
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{$U^\bot$ Decap}
        \KwIn{$c \in \mathcal{C}, \text{sk}$}
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $m = \bot$
        }{
            \Return{$\bot$};
        }
        \Return{$H(\hat{m}, c)$}
    \end{algorithm}
\end{multicols}

On the other hand, the implicit rejection KEM, denoted by $U^{\not\bot}$, generate a random message $m^\prime \leftsample \mathcal{M}$ as the fake input to $H$ when the ciphertext is invalid

\begin{multicols}{3}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{KeyGen}
        $\text{pk}, \text{sk} \leftsample \operatorname{KeyGen}()$\;
        $m^\prime \leftsample \mathcal{M}$\;
        \Return{$(\text{pk}, (\text{sk}, m^\prime))$}\;
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Encap}
        $m \leftsample \mathcal{M}$\;
        $c \leftarrow E^T(\text{pk}, m)$\;
        $K \leftarrow H(m, c)$\;
        \Return{$(c, K)$}
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Decap}
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $m = \bot$
        }{
            \Return{$H(m^\prime, c)$};
        }
        \Return{$H(\hat{m}, c)$}
    \end{algorithm}
\end{multicols}

The security result is similarly expressed in two theorems:

\begin{theorem}\label{ow-pcva-result}
    If the input asymmetric scheme is $\delta$-correct and $\gamma$-spread, then for every OW-PCVA adversary that issues at most $q_G$ hash queries and $q_V$ ciphertext validation queries with advantage $\epsilon^T$, there exists an IND-CPA adversary against the underlying asymmetric scheme with advantage $\epsilon$ such that

    \begin{equation*}
        \epsilon^T \leq q_G \cdot \delta + q_V \cdot 2^{-\gamma} 
            + \frac{2q_G + 1}{\norm{\mathcal{M}}}
            + 3\epsilon
    \end{equation*}
\end{theorem}

\begin{theorem}\label{cca-kem-result}
    For every IND-CCA2 adversary against the $U^\bot$ KEM with advantage $\epsilon^{U^\bot}$, there exists an OW-PCVA adversary against the input scheme $(E^T, D^T)$ with advantage $\epsilon^T$ such that

    \begin{equation*}
        \epsilon^{U^\bot} \leq \epsilon^T
    \end{equation*}
\end{theorem}

\begin{theorem}
    For every IND-CCA2 adversary against the $U^{\not\bot}$ KEM that issues $q_H$ hash queries with advantage $\epsilon^{U^{\not\bot}}$, there exists an OW-PCVA adversary against the input scheme $(E^T, D^T)$ with advantage $\epsilon^T$ such that

    \begin{equation*}
        \epsilon^{U^{\not\bot}} \leq \epsilon^T + \frac{q_H}{\norm{\mathcal{M}}}
    \end{equation*}
\end{theorem}

\subsection{A discussion of proof techniques}
The 1999 Fujisaki-Okamoto transformation and its 2017 variations deployed similar strategies for their respective security reductions: start with the appropriate standard IND-CCA game, then gradually transform the game into something that can be simulated by some adversary playing another standard OW-CPA or IND-CPA game (or in the case of the IND-CCA KEM, some adversary playing the OW-PCVA game).

In the standard games, the decryption oracle, the decapsulation oracle, the plaintext checking oracle, and the ciphertext validation oracles all behave as if they possess the true secret key and use the secret key to execute the decryption routine on their query inputs. However, thanks to the design of the transformed schemes, there are ways to simulate the behaviors of those oracles under the random oracle assumption by modeling the hash functions as probabilistic turing machines whose state is taped. The simulated oracles will behave differently from the true oracles in certain circumstances, so the transformed game will diverge from the original game, but because of the difference lemma, we can bound the loss of security by the probability of the diverging event.

\subsubsection{Simulate decryption oracle with random oracle}\label{simulate-dec-oracle}
The decryption oracle can be simulated without secret key by taking advantage of the fact that in an honest execution of the encryption routine, a hash of the message is used to generate the pseudorandom coin. Assuming that the random oracle records its queries, if the ciphertext is honestly generated, then the random oracle should contain exactly one record whose input contains the correct message.

Here is an example of comparing the standard decryption oracle with the simulated decryption oracle in the 1999 Fujisaki-Okamoto transformation, where the hash function $H: \{0, 1\}^\ast \rightarrow \text{Coin}$ is modeled as a probabilistic turing machine and used to recover the plaintext

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Standard decryption oracle}
        \KwIn{
            $\tilde{c} \in \mathcal{C}^\text{sym}, 
            \tilde{e} \in \mathcal{C}^\text{asym}$
        }
        \tcp*[h]{Check algorithm \ref{hybrid-decryption-99} for $D^\text{hy}$}
        $\hat{m} \leftarrow D^\text{hy}(\text{sk}, (\tilde{c}, \tilde{e}))$\;
        \Return{$\hat{m}$}
    \end{algorithm}


    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated decryption oracle}
        \KwIn{
            $\tilde{c} \in \mathcal{C}^\text{sym}
            , \tilde{e}\in\mathcal{C}^\text{asym}$
        }
        \If{
            $\exists (\sigma, c, r) \in \mathcal{O}^H$ such that
            $c = \tilde{c}$ 
            and $E^\text{asym}(\text{pk}, \sigma, r) = \tilde{e}$
        }{
            \tcp{We have found a decryption}
            $\hat{a} \leftarrow G(\sigma)$\;
            $\hat{m} \leftarrow D^\text{sym}_{\hat{a}}(c)$\;
            \Return{$\hat{m}$}
        }
        \Return{$\bot$}\;
    \end{algorithm}
\end{multicols}

The two oracles will behave differently if and only if the queried ciphertext is generated without querying the hash oracle, but if the hash oracle is not consulted, then the coin is indistinguishable from truly random. Therefore, the simulated oracle's behavior diverges from the standard oracle if and only if the adversary correctly guesses the ciphertext generated from a truly random coin. The probaility of such an event is bounded by the spread of the underlying encryption scheme.

\subsubsection{Random until queried}\label{random-until-queried}
In the 1999 transformation, both the symmetric key $a \leftarrow G(\sigma)$ and the asymmetric coin $r \leftarrow H(\sigma, c)$ are pseudorandom. In the 2017 transformation, the asymmetric coin $r \leftarrow H(m)$ is also pseudorandom. On the other hand, in the standard security game against any symmetric cipher, the secret key is truly random, and in the standard security game against an asymmetric cipher, the encryption coin is also truly random. This difference prevents an adversary playing the standard game to correctly simulate the challenge encryption in the IND-CCA2 game.

Under the random oracle model, this difference can be resolved by observing that there is no distinction between querying a random oracle once and randomly sampling from the specified probability space. In other words, unless the IND-CCA2 adversary makes a query to the random oracle with the specific input, from the IND-CCA2 adversary's perspective there is no difference between pseudorandom and truly random values, so the sequence of games can safely replace pseudorandom values with truly random values, and the difference in advantage will be bounded by the probability that the IND-CCA2 adversary indeed makes some very specific query. Finally, this probability can be bounded by a standard game adversary who can take advantage of the specific value being queried.

As an example, in the 1999 transformation's security reduction, consider an IND-CPA adversary against the underlying symmetric cipher $\mathcal{A}^\text{sym}_\text{IND-CPA}$. $\mathcal{A}^\text{sym}_\text{IND-CPA}$ tries to simulate the IND-CCA2 game for an adversary against the hybrid scheme $\mathcal{A}^\text{hy}_\text{IND-CCA}$ in the following steps:

\begin{enumerate}
    \item $\mathcal{A}^\text{sym}_\text{IND-CPA}$ runs hybrid KeyGen and passes pk to $\mathcal{A}^\text{hy}_\text{IND-CCA}$
    \item $\mathcal{A}^\text{sym}_\text{IND-CPA}$ simulates random oracle $H, G$ and the decryption oracle $\mathcal{O}^D$ using method described in section \ref{simulate-dec-oracle}
    \item When $\mathcal{A}^\text{hy}$ outputs the challenge messages $m_0, m_1$, $\mathcal{A}^\text{sym}$ passes these two messages to the symmetric cipher challenger. The symmetric challenger returns the encryption of one of them $c^\ast = E^\text{sym}_{a^\ast}(m_b)$ under a \textbf{truly random key $a^\ast$}
    \item $\mathcal{A}^\text{sym}$ samples random $\sigma \leftarrow \mathcal{M}^\text{asym}$, computes the coin $r \leftarrow H(c^\ast, \sigma)$ and the asymmetric ciphertext $e^\ast \leftarrow E^\text{asym}(\text{pk}, \sigma, r)$
    \item $\mathcal{A}^\text{sym}$ passes $(c^\ast, e^\ast)$ as the challenge ciphertext to $\mathcal{A}^\text{hy}$. When $\mathcal{A}^\text{hy}$ outputs the guess $\hat{b}$, $\mathcal{A}^\text{sym}$ passes $\hat{b}$ as its own output
\end{enumerate}

Note that in the simulation of the IND-CCA2 game above, the symmetric key for the challenge encryption in the IND-CCA2 game is truly random instead of pseudorandom. Let $G_a$ denote the IND-CCA2 game with truly random symmetric key (aka the simulation above), let $G_b$ denote the IND-CCA2 game with pseudorandom symmetric key, and let $\operatorname{QUERY}^\ast$ denote the event that the IND-CCA2 adversary queries $G$ with $m_b$, which is the diverging event between the two games. By the difference lemma:

\begin{equation*}
    \epsilon_a - \epsilon_b \leq P[\operatorname{QUERY}^\ast]
\end{equation*}

On the other hand, if the adversary indeed queries the hash $G(m_b)$, then the tape of the random oracle $G$ should contain an entry that matches one of $(m_0, m_1)$, which can then be used by another IND-CPA adversary:

\begin{equation*}
    P[\operatorname{QUERY}^\ast] \leq \epsilon_\text{IND-CPA}
\end{equation*}

\subsubsection{Plaintext checking, ciphertext validation, and patched decapsulation oracle}\label{patched-decap}
The concept of plaintext-checking attack (PCA) was proposed in early 2000s and first used in generic IND-CCA transformation by Coron et al in \textit{GEM: a generic chosen-ciphertext secure encryption method} \cite{jean2002gem}. Although PCA security is not a standard security definition, it is nonetheless useful as an intermediary step for constructing simple generic IND-CCA secure cryptosystems.

The standard plaintext-checking oracle (PCO) takes as input a plaintext-ciphertext pair $(m, c)$ and uses the secret key to determine whether they correspond to each other. Because lattice-based cryptosystems sometimes suffer from decryption errors, and because the OW-PCVA transformation $(E^T, D^T)$ is a deterministic encryption scheme, the standard PCO checks both encryption and decryption. When trying to simulate PCO without using the secret key, the decryption routine is omitted. Thanks for $E^T$ being deterministic, the behavior of the simulated PCO diverges from the standard PCO if and only if $m$ causes decryption error. The probability of decryption error is bounded by $\delta$-correctness.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Standard PCO}
        \KwIn{$(m \in \mathcal{M}, c \in \mathcal{C})$}
        \If{
            $E^T(\text{pk}, m) \neq c$
        }{
            \Return{$\bot$}\;
        }
        \If{
            $D^T(\text{sk}, c) \neq m$
        }{
            \Return{$\bot$}\;
        }
    \end{algorithm}

    \columnbreak
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated PCO}
        \KwIn{$(m \in \mathcal{M}, c \in \mathcal{C})$}
        \If{
            $E^T(\text{pk}, m) \neq c$
        }{
            \Return{$\bot$}\;
        }
    \end{algorithm}
\end{multicols}

In addition to PCO, Hofheinz \cite{hofheinz2017modular} also introduced a ciphertext-validation oracle (CVO) that checks whether the queried ciphertext is valid or not. The standard CVO uses the secret key to execute the decryption routine, and the simulated CVO uses the random oracle in a similar trick as described in section \ref{simulate-dec-oracle} with a similar loss of security.

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Standard CVO}
        \KwIn{
            $c \in \mathcal{C}$
        }
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $\hat{m} = \bot$
        }{
            \Return{$\bot$}
        }
        \If{
            $E^T(\text{pk}, \hat{m}) \neq c$
        }{
            \Return{$\bot$}
        }
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Simulated CVO}
        \KwIn{
            $c \in \mathcal{C}$
        }
        \If{
            $\not\exists (m, r) \in \mathcal{O}^G$ such that
            $E^T(\text{pk}, m) = c$
        }{
            \Return{$\bot$}
        }
    \end{algorithm}
\end{multicols}

The combination of PCO and CVO allows the decapsulation oracle to be simulated by an OW-PCVA adversary having access to these two oracles. The simulation is achieved by making both the hash oracle $H$ and the simulated decapsulation oracle $\mathcal{O}^D$ stateful, and allowing valid queries to $H$ be added to the state of $\mathcal{O}^D$ so that the output of $\mathcal{O}^D$ stays consistent. In this simulation $H$ \textbf{patches} the state of $\mathcal{O}^D$, hence we call this decapsulation ``patched".

\pagebreak

\begin{multicols}{2}
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Standard decap oracle}
        \KwIn{
            $c \in \mathcal{C}$
        }
        $\hat{m} \leftarrow D^T(\text{sk}, c)$\;
        \If{
            $\hat{m} \neq \bot$
        }{
            \Return{$H(\hat{m}, c)$}\;
        }
        \Return{$\bot$}\;
    \end{algorithm}
    \columnbreak

    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Patched hash oracle $H$}
        \KwIn{
            $m \in \mathcal{M}, c \in \mathcal{C}$
        }
        \If{
            $\exists (
                \tilde{m}, \tilde{c}, \tilde{K}
            ) \in \mathcal{O}^H$ such that $\tilde{m} = m, \tilde{c} = c$
        }{
            \Return{$\tilde{K}$}
        }
        $K \leftsample \mathcal{K}$\;
        Append $(m, c, K)$ to $\mathcal{O}^H$\;
        \If{
            $\operatorname{PCO}(m, c) \neq bot$
        }{
            Append $(c, K)$ to $\mathcal{O}^D$
        }
        \Return{$K$}
    \end{algorithm}
    
    \begin{algorithm}[H]
        \SetAlgoLined
        \caption{Patched decap oracle $\mathcal{O}^D$}
        \KwIn{$c \in \mathcal{C}$}
        \If{
            $\exists (\tilde{c}, \tilde{K}) \in \mathcal{O}^D$
            such that $\tilde{c} = c$
        }{
            \Return{$\tilde{K}$}
        }
        \If{
            $\operatorname{CVO}(c) \neq \bot$
        }{
            $K \leftsample \mathcal{K}$\;
            Append $(c, K)$ to $\mathcal{O}^D$\;
            \Return{$K$}
        }
        \Return{$\bot$}
        \tcp*[alignment]{Or the implicit rejection}
    \end{algorithm}
\end{multicols}

Under the random oracle model, the combination of patched hash function and patched decapsulation oracle should behave exactly the same as the standard decapsulation oracle.

\subsection{A sketch of proof}
Here we provide a sketch of the security proof for both the 1999 transformation and the 2017 variations. All three proofs follow the framework of sequence of games.

\subsubsection{Proof of theorem \ref{fo-1999-theorem}}
\begin{proof}
    Game 0 is the standard IND-CCA2 game.
    
    Game 1 is identical to Game 0, except for that the standard decryption oracle is replaced with the simulated decryption oracle described in section \ref{simulate-dec-oracle}. From the IND-CCA adversary's perspective, game 1 and game 0 are indistinguishable, except when the adversary makes one or more ciphertext query $(\tilde{c}, \tilde{e})$ to the decryption oracle without matching hash query $(m, c, r) \in \mathcal{O}^H$ such that $c = \tilde{c}$ and $E^\text{asym}(\text{pk}, m, r) = \tilde{c}$. Given that the adversary makes exactly $q_D$ decryption queries, the probability of ``at least one divergent query'' is:

    \begin{equation*}
        \begin{aligned}
            P[\text{at least 1 diverging decryption query}]
            &= P[\cup_{i=1}^{q_D} \text{ query $i$ is divergent}] \\
            &\leq \sum_{i=1}^{q_D}P[\text{query $i$ is divergent}] \\
            &= q_D2^{-\gamma}
        \end{aligned}
    \end{equation*}

    By the difference lemma, we know:

    \begin{equation}
        \epsilon_0 - \epsilon_1 
        \leq P[\text{at least 1 diverging decryption query}] 
        \leq q_D2^{-\gamma}
    \end{equation}

    Where $\epsilon_0$ and $\epsilon_1$ is the adversary's advantage in game 0 and game 1, respectively.

    Game 2 is identical to game 1, except for that in the challenge encryption, the both the symmetric key and the asymmetric coin are truly random instead of pseudorandom:

    \begin{multicols}{2}
        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{$G_1$ challenge encryption}
            \KwIn{$\text{pk}, m \in \mathcal{M}^\text{sym}$}
            $\sigma \leftsample \mathcal{M}^\text{asym}$\;
            $a \leftarrow G(\sigma)$; $c \leftarrow E^\text{sym}_a(m)$\;
            $r \leftarrow H(\sigma, c)$;
            $e \leftarrow E^\text{asym}(\text{pk}, m, r)$\;
            \Return{$(c, e)$}\;
        \end{algorithm}
        \columnbreak

        \begin{algorithm}[H]
            \SetAlgoLined
            \caption{$G_2$ challenge encryption}
            \KwIn{$\text{pk}, m \in \mathcal{M}^\text{sym}$}
            $\sigma \leftsample \mathcal{M}^\text{asym}$\;
            $a \leftsample \mathcal{K}^\text{sym}$; $c \leftarrow E^\text{sym}_a(m)$\;
            $r \leftsample \text{Coin}$;
            $e \leftarrow E^\text{asym}(\text{pk}, m, r)$\;
            \Return{$(c, e)$}\;
        \end{algorithm}
    \end{multicols}

    From the adversary's perspective, game 2 is identical to game 1 except for when the adversary queries either $G$ or $H$ with the $\sigma$ used in the challenge encryption:

    \begin{equation}
        \epsilon_1 - \epsilon_2 \leq P[\operatorname{QUERY}^\ast]
    \end{equation}

    Game 2 can be perfectly simulated by an IND-CPA adversary against the underlying symmetric cipher using the technique discussed in section \ref{random-until-queried}:

    \begin{equation}
        \epsilon_2 = \epsilon^\text{sym}_\text{IND-CPA}
    \end{equation}

    Game 2 can also be perfectly simulated by an OW-CPA adversary against the underlying asymmetric cipher. The OW-CPA adversary will pass the OW-CPA challenge ciphertext as the asymmetric part of the IND-CCA challenge ciphertext. After the IND-CCA adversary halts, the OW-CPA adversary will check the tape of the hash oracles and pick a random queried value $\tilde{\sigma}$ as its output. The OW-CPA adversary wins if and only if the IND-CCA adversary makes the divergent hash query and that the randomly picked query is the correct one:

    \begin{equation}
        P[\operatorname{QUERY}^\ast] \cdot \frac{1}{q_H} = \epsilon^\text{asym}_\text{OW-CPA}
    \end{equation}

    Summing the four equations above will bound the IND-CCA adversary's advantage in game 0.
\end{proof}

\subsubsection{Proof of theorem \ref{ow-pcva-result}}
\begin{proof}
    Game 0 is the OW-PCVA game, which is identical to the OW-CPA game, but the adversary also has access to the PCO and the CVO.

    Game 1 is identical to game 0, except for that the PCO is replaced with the simulated PCO. From the perspective of the OW-PCVA adversary, the two games are indistinguishable except for when the adversary produces a ciphertext $c$ from a plaintext $m$ that causes decryption error. Since each call to the encryption routine involves a call to the hash oracle, and assuming that the asymmetric cipher is $\delta$-correct, we can bound the change in the adversary's advantage:

    \begin{equation*}
        \epsilon_0 - \epsilon_1 
        \leq P[\text{at least one decryption error}]
        \leq q_G \cdot \delta
    \end{equation*}

    Game 2 is identical to game 1, except for that the CVO is replaced with the simulated CVO. Using the technique discussed in section \ref{simulate-dec-oracle}, we have:

    \begin{equation*}
        \epsilon_1 - \epsilon_2 \leq q_V \cdot 2^{-\gamma}
    \end{equation*}

    Game 3 is identical to game 2, except for that the challenge encryption is performed using a truly random coin $r^\ast \leftsample \text{Coin}$ instead of the pseudorandom coin $r^\ast \leftarrow G(m)$. Using the argument in section \ref{random-until-queried}:

    \begin{equation*}
        \epsilon_2 - \epsilon_3 \leq P[\operatorname{QUERY}^\ast]
    \end{equation*}

    Game 3 can be perfectly simulated by a OW-CPA adversary against the underlying asymmetric cipher:

    \begin{equation*}
        \epsilon_3 = \epsilon_\text{OW-CPA}
    \end{equation*}

    Game 3 can also be simulated by an IND-CPA adversary against the underlying asymmetric cipher who passes the IND-CPA challenge ciphertext to the OW-PCVA adversary. If the OW-PCVA adversary queries $G$ with the value of $m^\ast$, then the IND-CPA adversary will find in the tape of the hash oracle $G$ a value that matches one its own challenge plaintexts. If no match is found, the IND-CPA adversary will output a random coin toss. Thus, the advantage of this IND-CPA adversary is exactly the probability $P[\operatorname{QUERY}^\ast]$:

    \begin{equation*}
        P[\operatorname{QUERY}^\ast] = \epsilon_\text{IND-CPA}
    \end{equation*}

    The four equations above, combined with the result in section \ref{ind-cpa-to-ow-cpa}, will bound the advantage of the OW-PCVA adversary
\end{proof}

\subsubsection{Proof of theorem \ref{cca-kem-result}}
\begin{proof}
    Game 0 is the IND-CCA KEM game.

    Game 1 is identical to game 0, except for that the decapsulation oracle is replaced with the patched hash oracle plus the patched decapsulation oracle. Using the argument in section \ref{patched-decap}, from the perspective of the adversary, the two games are indistinguishable:

    \begin{equation*}
        \epsilon_0 = \epsilon_1
    \end{equation*}

    Game 2 is identical to game 1, except for that in the challenge encapsulation, the shared secret is truly random $K^\ast \leftsample \mathcal{K}$ instead of pseudorandom $K^\ast \leftarrow H(m, c)$. Game 2 diverges from game 1 in ways described in section \ref{random-until-queried}

    \begin{equation*}
        \epsilon_1 - \epsilon_2 = P[\operatorname{QUERY}^\ast]
    \end{equation*}

    If the IND-CCA KEM adversary indeed makes a hash query on the challenge values $(m^\ast, c^\ast)$, then an OW-PCVA adversary can check the hash oracle's tape to decrypt a challenge encryption:

    \begin{equation*}
        P[\operatorname{QUERY}^\ast] = \epsilon_\text{OW-PCVA}
    \end{equation*}

    Finally, since $K^\ast$ is always truly random, no adversary can have any advantage in game 2:

    \begin{equation*}
        \epsilon_2 = 0
    \end{equation*}
\end{proof}

\section{Future works on generic IND-CCA transformation}
The 2017 transformations $U^\bot$ and $U^{\not\bot}$ have been largely successful in its simple constructions and robust security result, and the latter is adopted by NIST PQC winners such as Kyber. However, there are still continuous work on further improving the Fujisaki-Okamoto transformation. Here are a few open questions in the field:

\subsection{Security in the quantum random oracle model}
The weakest link in all of the transformations and their security reduction above is the random oracle model. In addition, as the prospect of quantum computer looms bigger, there is an increasingly urgent need to re-consider the random oracle model in the quantum setting. For example, a quantum computer can compute the hash values of a superposition of inputs, although due to the nuance of quantum mechanics that are outside this author's capacity, quantum random oracles are not a straightforward upgrade of computing capabilities from the non-quantum random oracle model. Taking a step back, the entire premise of quantum security remains an open question.

\subsection{Better handling of decryption error}
In the 2017 transformation, decryption error is handled with a shotgun approach: the authors simply assumed that the probability of an adversary coming up with a message $m$ that would cause decryption error is negligible, but in practice this probability is still an non-trivial factor, and some adversary may choose such message $m$ adversarially, thus making the loss of security potentially non-trivial.

\subsection{Removing re-encryption}
The re-encryption step in the decryption routine is the source of ciphertext integrity and thus an essential component to the IND-CCA security of the Fujisaki-Okamoto transformation. Unfortunately, this step is also very computationally expensive (this is especially true in Kyber, whose encryption routine involves computing and storing the entire public-key matrix $A \in R_q^{k \times k}$ but whose decryption routine involves much less computation and memory requirements). There might be other ways to provide integrity with better performance characteristics. For example, classic McEliece achieves integrity through the unique properties of Goppa code and the syndrome decoding problem, although this approach lacks generality and is not readily applicable to lattice-based schemes like Kyber. Symmetric integrity primitives like message authentication code (MAC) are also promising candidates, though the security implications remain unproven.

\bibliographystyle{plain}
\bibliography{./references.bib}

\end{document}